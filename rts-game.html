<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animal RTS - Choose Your Army</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow: visible;
            height: 100%;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: visible;
            height: 100%;
            position: relative;
        }

        /* Title Screen */
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #titleScreen h1 {
            color: white;
            font-size: 3rem;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #titleScreen p {
            color: white;
            font-size: 1.2rem;
            margin-bottom: 3rem;
            text-align: center;
        }

        .animal-selection {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 800px;
        }

        .animal-card {
            background: rgba(255,255,255,0.1);
            border: 3px solid transparent;
            border-radius: 15px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 120px;
            text-align: center;
        }

        .animal-card:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-5px);
        }

        .animal-card.selected {
            border-color: #00ff88;
            background: rgba(0,255,136,0.2);
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        .animal-card h3 {
            color: white;
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        .animal-card p {
            color: rgba(255,255,255,0.8);
            font-size: 0.8rem;
            margin: 0;
        }

        .start-btn {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.5;
            pointer-events: none;
        }

        .start-btn.enabled {
            opacity: 1;
            pointer-events: all;
        }

        .start-btn:hover.enabled {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,255,136,0.4);
        }

        /* Game Screen */
        #gameScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            cursor: crosshair;
            position: relative;
            z-index: 1;
        }

        /* 3D Models Container */
        #modelsContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .unit-model {
            position: absolute;
            pointer-events: none;
            z-index: 15;
        }

        .unit-model model-viewer {
            width: 100%;
            height: 100%;
            --progress-bar-display: none;
        }

        .unit-model.selected model-viewer {
            filter: drop-shadow(0 0 10px #00ff88);
        }

        /* Hex Grid Terrain System */
        #hexGridContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            opacity: 0.8;
        }

        #hex-grid {
            position: absolute;
            top: 50px;
            left: 50px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            --hex-tile-size: 80px;
        }

        .hex-row {
            display: flex;
            gap: 2px;
            margin-bottom: -10px;
        }

        .hex-row.offset-row {
            margin-left: calc(var(--hex-tile-size) / 2);
        }

        .hex-row.offset-row .hex-tile {
            transform: rotate(90deg);
        }

        .hex-tile {
            width: var(--hex-tile-size);
            height: var(--hex-tile-size);
            background: transparent;
            --progress-bar-display: none;
            margin: 0;
            padding: 0;
            transition: transform 0.2s ease;
            /* Create hexagonal shape using clip-path */
            clip-path: polygon(30% 0%, 70% 0%, 100% 50%, 70% 100%, 30% 100%, 0% 50%);
        }

        .hex-tile:hover {
            transform: scale(1.05);
            z-index: 10;
        }

        .hex-row.offset-row .hex-tile:hover {
            transform: rotate(90deg) scale(1.05);
        }

        /* UI Elements */
        .ui-panel {
            position: absolute;
            background: rgba(0,0,0,0.8);
            border-radius: 10px;
            padding: 1rem;
            color: white;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        #resourcePanel {
            top: 20px;
            left: 20px;
        }

        #controlPanel {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
        }

        .animal-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 0.5rem 1rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .animal-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.5);
        }

        .animal-btn.active {
            background: rgba(0,255,136,0.3);
            border-color: #00ff88;
        }

        #selectionBox {
            position: absolute;
            border: 2px dashed #00ff88;
            background: rgba(0,255,136,0.1);
            pointer-events: none;
            display: none;
            z-index: 50;
        }

        /* Mini-map */
        #miniMap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
        }

        /* Loading indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            z-index: 1001;
        }
    </style>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
</head>
<body>
    <!-- Title Screen -->
    <div id="titleScreen">
        <h1>üéÆ Animal RTS</h1>
        <p>Choose 3 animals to build your army and conquer the battlefield!</p>
        
        <div class="animal-selection">
            <div class="animal-card" data-animal="bear">
                <h3>üêª Bear</h3>
                <p>Strong & Durable<br>Slow but powerful units</p>
            </div>
            <div class="animal-card" data-animal="bee">
                <h3>üêù Bee</h3>
                <p>Fast & Agile<br>Quick swarm attacks</p>
            </div>
            <div class="animal-card" data-animal="turtle">
                <h3>üê¢ Turtle</h3>
                <p>Defensive<br>High armor, steady advance</p>
            </div>
            <div class="animal-card" data-animal="fox">
                <h3>ü¶ä Fox</h3>
                <p>Cunning & Quick<br>Hit and run tactics</p>
            </div>
            <div class="animal-card" data-animal="frog">
                <h3>üê∏ Frog</h3>
                <p>Amphibious<br>Can cross water</p>
            </div>
            <div class="animal-card" data-animal="owl">
                <h3>ü¶â Owl</h3>
                <p>Air Support<br>Flying reconnaissance</p>
            </div>
            <div class="animal-card" data-animal="pig">
                <h3>üê∑ Pig</h3>
                <p>Resource Gatherer<br>Boosts economy</p>
            </div>
            <div class="animal-card" data-animal="cat">
                <h3>üê± Cat</h3>
                <p>Stealth Hunter<br>Invisible attacks</p>
            </div>
            <div class="animal-card" data-animal="chicken">
                <h3>üêî Chicken</h3>
                <p>Rapid Breeder<br>Fast unit production</p>
            </div>
            <div class="animal-card" data-animal="dolphin">
                <h3>üê¨ Dolphin</h3>
                <p>Naval Unit<br>Controls waterways</p>
            </div>
        </div>
        
        <button class="start-btn" id="startBtn">Start Game</button>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen">
        <canvas id="gameCanvas"></canvas>
        
        <!-- 3D Models Container -->
        <div id="modelsContainer"></div>
        
        <!-- Hex Grid Terrain Container -->
        <div id="hexGridContainer">
            <div id="hex-grid"></div>
        </div>
        
        <!-- UI Panels -->
        <div id="resourcePanel" class="ui-panel">
            <div>Population: <span id="population">0</span></div>
            <div>Selected: <span id="selectedCount">0</span></div>
        </div>

        <div id="controlPanel" class="ui-panel">
            <!-- Animal control buttons will be dynamically added here -->
        </div>

        <div id="miniMap" class="ui-panel">
            <canvas id="miniMapCanvas" width="200" height="150"></canvas>
        </div>

        <div id="selectionBox"></div>
    </div>

    <div class="loading" id="loadingIndicator" style="display: none;">Loading 3D Models...</div>

    <script>
        // Game State
        let gameState = {
            selectedAnimals: [],
            units: [],
            bases: [],
            selectedUnits: [],
            gameStarted: false,
            population: 0,
            lastSpawnTime: 0,
            camera: { x: 0, y: 0 },
            isSelecting: false,
            selectionStart: { x: 0, y: 0 },
            mapSize: { width: 2000, height: 1500 },
            modelsLoaded: false
        };

        // Animal configurations with 3D model paths
        const animalConfigs = {
            bear: { speed: 1, size: 40, model: 'models/Bear.glb', baseStyle: 'cave', emoji: 'üêª' },
            bee: { speed: 3, size: 20, model: 'models/Bee.glb', baseStyle: 'hive', emoji: 'üêù' },
            turtle: { speed: 0.5, size: 35, model: 'models/Turtle.glb', baseStyle: 'pond', emoji: 'üê¢' },
            fox: { speed: 2.5, size: 25, model: 'models/Fox.glb', baseStyle: 'den', emoji: 'ü¶ä' },
            frog: { speed: 2, size: 22, model: 'models/Frog.glb', baseStyle: 'lily', emoji: 'üê∏' },
            owl: { speed: 2, size: 30, model: 'models/Owl.glb', baseStyle: 'tree', emoji: 'ü¶â' },
            pig: { speed: 1.5, size: 28, model: 'models/Pig.glb', baseStyle: 'pen', emoji: 'üê∑' },
            cat: { speed: 2.2, size: 24, model: 'models/cat.glb', baseStyle: 'house', emoji: 'üê±' },
            chicken: { speed: 1.8, size: 20, model: 'models/Chicken.glb', baseStyle: 'coop', emoji: 'üêî' },
            dolphin: { speed: 2.5, size: 38, model: 'models/dolphin.glb', baseStyle: 'pool', emoji: 'üê¨' }
        };

        /* --------------------
           Phase 0 ‚Äì Ground-rules & Tile Legend (two-player map)
        ---------------------*/

        // Single source of truth for every terrain / base tile
        const TileType = Object.freeze({
            PLAYER_BASE:   'playerBase',   // b ‚Äì will be bound to chosen animals later
            ENEMY_BASE:    'enemyBase',    // e ‚Äì NPC bases
            MOUNTAIN:      'mountain',     // m
            LAKE:          'lake',         // l (clusters post-processed ‚Üí river/ocean)
            RIVER:         'river',        // r
            OCEAN:         'ocean',        // o
            FARMLAND:      'farmland',     // f
            WETLAND:       'wetland',      // w
            PLAIN:         'plain'         // p (default)
        });

        // Mapping from CSV character to TileType for quick parsing (Phase 1 will use this)
        const TILE_CHAR = Object.freeze({
            'b': TileType.PLAYER_BASE,
            'e': TileType.ENEMY_BASE,
            'm': TileType.MOUNTAIN,
            'l': TileType.LAKE,
            'r': TileType.RIVER,
            'o': TileType.OCEAN,
            'f': TileType.FARMLAND,
            'w': TileType.WETLAND,
            'p': TileType.PLAIN,
            '':  TileType.PLAIN
        });

        // Two-team setup: human player vs single NPC (AI)
        const Teams = Object.freeze({
            PLAYER: 'player',
            NPC:    'enemy'   // retains previous naming for compatibility
        });

        // Hex grid terrain system
        const hexTileModels = [
            { file: 'models/Mountain.glb', alt: 'Mountain Tile' },
            { file: 'models/Forest.glb', alt: 'Forest Tile' },
            { file: 'models/Hill.glb', alt: 'Hill Tile' },
            { file: 'models/FarmLand.glb', alt: 'Farm Land Tile' }
        ];

        function getRandomHexTile() {
            return hexTileModels[Math.floor(Math.random() * hexTileModels.length)];
        }

        function generateHexGrid(rows = 15, cols = 20) {
            const container = document.getElementById('hex-grid');
            if (!container) {
                console.warn('Hex grid container (#hex-grid) not found.');
                return;
            }

            // Clear any existing tiles
            container.innerHTML = '';

            for (let r = 0; r < rows; r++) {
                const rowEl = document.createElement('div');
                rowEl.classList.add('hex-row');
                
                // Offset every other row by half a tile width for proper hex interlocking
                if (r % 2 === 1) {
                    rowEl.classList.add('offset-row');
                }

                // Adjust column count for offset rows to maintain visual balance
                const colsForRow = (r % 2 === 1) ? cols - 1 : cols;

                for (let c = 0; c < colsForRow; c++) {
                    const { file, alt } = getRandomHexTile();
                    const tile = document.createElement('model-viewer');
                    tile.classList.add('hex-tile');
                    tile.setAttribute('src', file);
                    tile.setAttribute('alt', alt);
                    tile.setAttribute('camera-controls', '');
                    tile.setAttribute('interaction-prompt', 'none');
                    tile.setAttribute('loading', 'lazy');
                    // Perfect top-down view (looking straight down) - pulled back 195m
                    tile.setAttribute('camera-orbit', '0deg 0deg 195m');
                    tile.setAttribute('field-of-view', '20deg');
                    // Disable all rotation and movement
                    tile.removeAttribute('auto-rotate');
                    tile.setAttribute('disable-zoom', '');
                    tile.setAttribute('disable-pan', '');
                    tile.setAttribute('min-camera-orbit', '0deg 0deg 195m');
                    tile.setAttribute('max-camera-orbit', '0deg 0deg 195m');

                    rowEl.appendChild(tile);
                }

                container.appendChild(rowEl);
            }
        }

        // Title Screen Logic
        document.addEventListener('DOMContentLoaded', function() {
            const animalCards = document.querySelectorAll('.animal-card');
            const startBtn = document.getElementById('startBtn');

            animalCards.forEach(card => {
                card.addEventListener('click', function() {
                    const animal = this.dataset.animal;
                    
                    if (this.classList.contains('selected')) {
                        this.classList.remove('selected');
                        gameState.selectedAnimals = gameState.selectedAnimals.filter(a => a !== animal);
                    } else if (gameState.selectedAnimals.length < 3) {
                        this.classList.add('selected');
                        gameState.selectedAnimals.push(animal);
                    }

                    // Update start button
                    if (gameState.selectedAnimals.length === 3) {
                        startBtn.classList.add('enabled');
                        startBtn.textContent = `Start with ${gameState.selectedAnimals.map(a => animalConfigs[a].emoji).join(' ')}`;
                    } else {
                        startBtn.classList.remove('enabled');
                        startBtn.textContent = `Select ${3 - gameState.selectedAnimals.length} more animals`;
                    }
                });
            });

            startBtn.addEventListener('click', function() {
                if (gameState.selectedAnimals.length === 3) {
                    startGame();
                }
            });
        });

        function startGame() {
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            document.getElementById('loadingIndicator').style.display = 'block';
            gameState.gameStarted = true;

            // Preload models then initialize game
            preloadModels().then(() => {
                document.getElementById('loadingIndicator').style.display = 'none';
                initializeGame();
                // No tree initialization needed
                gameLoop();
            });
        }

        async function preloadModels() {
            const modelsToLoad = gameState.selectedAnimals.map(animal => animalConfigs[animal].model);
            // No additional models to preload
            
            // Create invisible model-viewers to preload
            const preloadContainer = document.createElement('div');
            preloadContainer.style.position = 'absolute';
            preloadContainer.style.top = '-1000px';
            preloadContainer.style.left = '-1000px';
            document.body.appendChild(preloadContainer);

            const loadPromises = modelsToLoad.map(modelPath => {
                return new Promise((resolve, reject) => {
                    const modelViewer = document.createElement('model-viewer');
                    modelViewer.src = modelPath;
                    modelViewer.style.width = '1px';
                    modelViewer.style.height = '1px';
                    
                    modelViewer.addEventListener('load', () => {
                        resolve();
                    });
                    
                    modelViewer.addEventListener('error', () => {
                        console.warn(`Failed to load model: ${modelPath}`);
                        resolve(); // Continue even if model fails to load
                    });
                    
                    preloadContainer.appendChild(modelViewer);
                    
                    // Timeout fallback
                    setTimeout(() => resolve(), 3000);
                });
            });

            await Promise.all(loadPromises);
            document.body.removeChild(preloadContainer);
            gameState.modelsLoaded = true;
        }

        function initializeGame() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Generate hex grid terrain
            generateHexGrid();

            // Create bases for selected animals
            gameState.selectedAnimals.forEach((animal, index) => {
                const base = {
                    animal: animal,
                    team: 'player',
                    x: 200 + (index * 150),
                    y: 200,
                    lastSpawn: 0,
                    spawnInterval: 15000, // 15 seconds
                    size: 40
                };
                gameState.bases.push(base);
            });

            // Create enemy bases with 3 random remaining animals
            const remainingAnimals = Object.keys(animalConfigs).filter(a => !gameState.selectedAnimals.includes(a));
            // Shuffle simple
            for (let i = remainingAnimals.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [remainingAnimals[i], remainingAnimals[j]] = [remainingAnimals[j], remainingAnimals[i]];
            }
            const enemyAnimals = remainingAnimals.slice(0, 3);

            enemyAnimals.forEach((animal, index) => {
                const base = {
                    animal: animal,
                    team: 'enemy',
                    x: gameState.mapSize.width - (200 + (index * 150)),
                    y: gameState.mapSize.height - 200,
                    lastSpawn: 0,
                    spawnInterval: 15000,
                    size: 40
                };
                gameState.bases.push(base);
            });

            // Create control buttons
            createControlButtons();

            // Add event listeners
            setupEventListeners();
        }

        function createControlButtons() {
            const controlPanel = document.getElementById('controlPanel');
            controlPanel.innerHTML = '';

            gameState.selectedAnimals.forEach(animal => {
                const btn = document.createElement('button');
                btn.className = 'animal-btn';
                btn.textContent = `Select All ${animalConfigs[animal].emoji}`;
                btn.dataset.animal = animal;
                btn.addEventListener('click', () => selectAllUnitsOfType(animal));
                controlPanel.appendChild(btn);
            });
        }

        function setupEventListeners() {
            const canvas = document.getElementById('gameCanvas');

            // Mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);

            // Window resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                updateUnitModelPositions();
            });
        }

        function handleMouseDown(e) {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left + gameState.camera.x;
            const y = e.clientY - rect.top + gameState.camera.y;

            if (e.button === 0) { // Left click
                startSelection(x, y);
            } else if (e.button === 2) { // Right click
                moveSelectedUnits(x, y);
            }
        }

        function handleMouseMove(e) {
            if (gameState.isSelecting) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left + gameState.camera.x;
                const y = e.clientY - rect.top + gameState.camera.y;
                updateSelection(x, y);
            }
        }

        function handleMouseUp(e) {
            if (gameState.isSelecting) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left + gameState.camera.x;
                const y = e.clientY - rect.top + gameState.camera.y;
                finishSelection(x, y);
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = e.target.getBoundingClientRect();
            const x = touch.clientX - rect.left + gameState.camera.x;
            const y = touch.clientY - rect.top + gameState.camera.y;
            
            startSelection(x, y);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (gameState.isSelecting && e.touches.length === 1) {
                const touch = e.touches[0];
                const rect = e.target.getBoundingClientRect();
                const x = touch.clientX - rect.left + gameState.camera.x;
                const y = touch.clientY - rect.top + gameState.camera.y;
                updateSelection(x, y);
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (gameState.isSelecting) {
                if (e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    const rect = e.target.getBoundingClientRect();
                    const x = touch.clientX - rect.left + gameState.camera.x;
                    const y = touch.clientY - rect.top + gameState.camera.y;
                    finishSelection(x, y);
                }
            }
        }

        function startSelection(x, y) {
            // Check if clicking on a unit first
            const clickedUnit = gameState.units.find(unit => {
                const dx = unit.x - x;
                const dy = unit.y - y;
                return Math.sqrt(dx * dx + dy * dy) < unit.size;
            });

            if (clickedUnit) {
                // Single unit selection
                gameState.selectedUnits = [clickedUnit];
                updateSelectedCount();
                updateUnitSelectionVisuals();
            } else {
                // Start box selection
                gameState.isSelecting = true;
                gameState.selectionStart = { x, y };
                gameState.selectedUnits = [];
                updateSelectedCount();
                updateUnitSelectionVisuals();
            }
        }

        function updateSelection(x, y) {
            const selectionBox = document.getElementById('selectionBox');
            const canvas = document.getElementById('gameCanvas');
            
            const startX = Math.min(gameState.selectionStart.x - gameState.camera.x, x - gameState.camera.x);
            const startY = Math.min(gameState.selectionStart.y - gameState.camera.y, y - gameState.camera.y);
            const width = Math.abs(x - gameState.selectionStart.x);
            const height = Math.abs(y - gameState.selectionStart.y);

            selectionBox.style.left = startX + 'px';
            selectionBox.style.top = startY + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
            selectionBox.style.display = 'block';
        }

        function finishSelection(x, y) {
            gameState.isSelecting = false;
            document.getElementById('selectionBox').style.display = 'none';

            // Find units within selection box
            const minX = Math.min(gameState.selectionStart.x, x);
            const maxX = Math.max(gameState.selectionStart.x, x);
            const minY = Math.min(gameState.selectionStart.y, y);
            const maxY = Math.max(gameState.selectionStart.y, y);

            gameState.selectedUnits = gameState.units.filter(unit => 
                unit.team === 'player' &&
                unit.x >= minX && unit.x <= maxX && 
                unit.y >= minY && unit.y <= maxY
            );

            updateSelectedCount();
            updateUnitSelectionVisuals();
        }

        function moveSelectedUnits(x, y) {
            if (gameState.selectedUnits.length > 0) {
                // Create formation around target point
                const formationRadius = Math.sqrt(gameState.selectedUnits.length) * 20;
                
                gameState.selectedUnits.forEach((unit, index) => {
                    const angle = (index / gameState.selectedUnits.length) * Math.PI * 2;
                    const offsetX = Math.cos(angle) * formationRadius;
                    const offsetY = Math.sin(angle) * formationRadius;
                    
                    unit.targetX = x + offsetX;
                    unit.targetY = y + offsetY;
                    unit.isMoving = true;
                });
            }
        }

        function selectAllUnitsOfType(animalType) {
            gameState.selectedUnits = gameState.units.filter(unit => unit.animal === animalType && unit.team === 'player');
            updateSelectedCount();
            updateUnitSelectionVisuals();

            // Visual feedback
            const buttons = document.querySelectorAll('.animal-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-animal="${animalType}"]`).classList.add('active');
        }

        function createUnitModel(unit) {
            const modelContainer = document.createElement('div');
            modelContainer.className = 'unit-model';
            modelContainer.id = `unit-${unit.id}`;
            
            const modelViewer = document.createElement('model-viewer');
            modelViewer.src = animalConfigs[unit.animal].model;
            modelViewer.alt = `${unit.animal} unit`;
            modelViewer.autoRotate = false;
            modelViewer.cameraControls = false;
            modelViewer.disableZoom = true;
            modelViewer.rotationPerSecond = '0deg';
            modelViewer.style.width = (unit.size * 3) + 'px';
            modelViewer.style.height = (unit.size * 3) + 'px';
            
            // Fix camera and framing to prevent clipping
            modelViewer.cameraOrbit = '0deg 90deg 50m';
            modelViewer.fieldOfView = '10deg';
            modelViewer.minCameraOrbit = 'auto auto auto';
            modelViewer.maxCameraOrbit = 'auto auto auto';
            modelViewer.setAttribute('camera-target', 'auto auto auto');
            modelViewer.setAttribute('max-field-of-view', '45deg');
            modelViewer.setAttribute('min-field-of-view', '5deg');
            
            // Core model-viewer settings to prevent internal clipping
            modelViewer.setAttribute('auto-rotate-delay', '0');
            modelViewer.setAttribute('interaction-prompt', 'none');
            modelViewer.setAttribute('loading', 'eager');
            modelViewer.setAttribute('reveal', 'auto');
            
            // Wait for model to load then adjust framing
            modelViewer.addEventListener('load', () => {
                // Get the model's actual bounds and adjust camera accordingly
                setTimeout(() => {
                    try {
                        const center = modelViewer.getCameraTarget();
                        const bounds = modelViewer.getBoundingBoxCenter();
                        // Set camera far enough to see entire model
                        modelViewer.cameraOrbit = '0deg 75deg 100m';
                        modelViewer.fieldOfView = '15deg';
                    } catch (e) {
                        // Fallback if bounds calculation fails
                        modelViewer.cameraOrbit = '0deg 75deg 80m';
                        modelViewer.fieldOfView = '20deg';
                    }
                }, 100);
            });
            
            modelContainer.appendChild(modelViewer);
            document.getElementById('modelsContainer').appendChild(modelContainer);
            
            return modelContainer;
        }

        function spawnUnit(base) {
            const angle = Math.random() * Math.PI * 2;
            const distance = base.size + 30;
            
            const unit = {
                animal: base.animal,
                team: base.team,
                x: base.x + Math.cos(angle) * distance,
                y: base.y + Math.sin(angle) * distance,
                targetX: null,
                targetY: null,
                isMoving: false,
                size: animalConfigs[base.animal].size,
                speed: animalConfigs[base.animal].speed,
                id: Date.now() + Math.random(),
                modelElement: null
            };

            // Create 3D model for the unit
            unit.modelElement = createUnitModel(unit);
            
            gameState.units.push(unit);
            gameState.population++;
        }

        function updateUnits(deltaTime) {
            gameState.units.forEach(unit => {
                if (unit.isMoving && unit.targetX !== null && unit.targetY !== null) {
                    const dx = unit.targetX - unit.x;
                    const dy = unit.targetY - unit.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 5) {
                        const moveX = (dx / distance) * unit.speed;
                        const moveY = (dy / distance) * unit.speed;
                        unit.x += moveX;
                        unit.y += moveY;
                        
                        // Rotate model to face movement direction (rotate the model, not the camera)
                        if (unit.modelElement) {
                            const angleRad = Math.atan2(dy, dx); // radians
                            const angleDeg = (angleRad * 180 / Math.PI);
                            const modelViewer = unit.modelElement.querySelector('model-viewer');
                            if (modelViewer) {
                                // Adjust yaw so that the model front aligns with motion direction.
                                // Most GLB exports have the model facing the -Z axis; offset by +90 deg.
                                const yaw = -(angleDeg - 90); // Negate for correct handedness & offset
                                modelViewer.setAttribute('rotation', `0deg ${yaw.toFixed(2)}deg 0deg`);
                            }
                        }
                    } else {
                        unit.isMoving = false;
                        unit.targetX = null;
                        unit.targetY = null;
                    }
                }

                if (unit.team === 'enemy' && !unit.isMoving) {
                    // Simple AI: move toward nearest player base
                    const playerBases = gameState.bases.filter(b => b.team === 'player');
                    if (playerBases.length > 0) {
                        let nearest = playerBases[0];
                        let nearestDist = Math.hypot(nearest.x - unit.x, nearest.y - unit.y);
                        playerBases.forEach(b => {
                            const d = Math.hypot(b.x - unit.x, b.y - unit.y);
                            if (d < nearestDist) {
                                nearest = b;
                                nearestDist = d;
                            }
                        });
                        unit.targetX = nearest.x;
                        unit.targetY = nearest.y;
                        unit.isMoving = true;
                    }
                }
            });
            
            updateUnitModelPositions();
        }

        function updateUnitModelPositions() {
            gameState.units.forEach(unit => {
                if (unit.modelElement) {
                    const modelSize = unit.size * 3; // Keep consistent with creation size
                    const screenX = unit.x - gameState.camera.x - modelSize/2;
                    const screenY = unit.y - gameState.camera.y - modelSize/2;
                    
                    unit.modelElement.style.left = screenX + 'px';
                    unit.modelElement.style.top = screenY + 'px';
                    // Don't resize - maintain original size to prevent clipping
                    // unit.modelElement.style.width = modelSize + 'px';
                    // unit.modelElement.style.height = modelSize + 'px';
                }
            });
            
            // No tree position updates needed
        }

        function updateUnitSelectionVisuals() {
            gameState.units.forEach(unit => {
                if (unit.modelElement) {
                    if (gameState.selectedUnits.includes(unit)) {
                        unit.modelElement.classList.add('selected');
                    } else {
                        unit.modelElement.classList.remove('selected');
                    }
                }
            });
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = gameState.selectedUnits.length;
            document.getElementById('population').textContent = gameState.population;
        }

        function render() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Save context for camera transform
            ctx.save();
            ctx.translate(-gameState.camera.x, -gameState.camera.y);

            // Draw bases
            gameState.bases.forEach(base => {
                const config = animalConfigs[base.animal];
                
                // Base structure
                ctx.fillStyle = '#4a4a4a';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                
                // Different base shapes based on animal
                if (config.baseStyle === 'hive') {
                    drawHexagon(ctx, base.x, base.y, base.size);
                } else if (config.baseStyle === 'pond') {
                    ctx.beginPath();
                    ctx.arc(base.x, base.y, base.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.fillRect(base.x - base.size/2, base.y - base.size/2, base.size, base.size);
                    ctx.strokeRect(base.x - base.size/2, base.y - base.size/2, base.size, base.size);
                }

                // Base emoji
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#fff';
                ctx.fillText(config.emoji, base.x, base.y + 8);
            });

            // Draw movement target indicators for selected units
            gameState.selectedUnits.forEach(unit => {
                if (unit.isMoving && unit.targetX && unit.targetY) {
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(unit.x, unit.y);
                    ctx.lineTo(unit.targetX, unit.targetY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Target marker
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.arc(unit.targetX, unit.targetY, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.restore();

            // Draw mini-map
            renderMiniMap();
        }

        function drawHexagon(ctx, x, y, size) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                const px = x + Math.cos(angle) * size;
                const py = y + Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function renderMiniMap() {
            const miniCanvas = document.getElementById('miniMapCanvas');
            const miniCtx = miniCanvas.getContext('2d');
            
            // Clear mini-map
            miniCtx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);
            
            const scaleX = miniCanvas.width / gameState.mapSize.width;
            const scaleY = miniCanvas.height / gameState.mapSize.height;

            // Draw bases on mini-map
            gameState.bases.forEach(base => {
                miniCtx.fillStyle = '#4a4a4a';
                miniCtx.fillRect(
                    base.x * scaleX - 2, 
                    base.y * scaleY - 2, 
                    4, 4
                );
            });

            // Draw units on mini-map
            gameState.units.forEach(unit => {
                miniCtx.fillStyle = gameState.selectedUnits.includes(unit) ? '#00ff88' : '#ffffff';
                miniCtx.fillRect(
                    unit.x * scaleX - 1, 
                    unit.y * scaleY - 1, 
                    2, 2
                );
            });

            // Draw camera view
            const cameraX = gameState.camera.x * scaleX;
            const cameraY = gameState.camera.y * scaleY;
            const cameraW = window.innerWidth * scaleX;
            const cameraH = window.innerHeight * scaleY;
            
            miniCtx.strokeStyle = '#fff';
            miniCtx.lineWidth = 1;
            miniCtx.strokeRect(cameraX, cameraY, cameraW, cameraH);
        }

        function gameLoop() {
            if (!gameState.gameStarted) return;

            const currentTime = Date.now();
            const deltaTime = currentTime - (gameState.lastTime || currentTime);
            gameState.lastTime = currentTime;

            // Spawn units from bases
            gameState.bases.forEach(base => {
                if (currentTime - base.lastSpawn > base.spawnInterval) {
                    spawnUnit(base);
                    base.lastSpawn = currentTime;
                }
            });

            // Update units
            updateUnits(deltaTime);

            // Render
            render();

            // Continue game loop
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html> 