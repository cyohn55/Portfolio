<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animal RTS - Choose Your Army</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow: visible;
            height: 100%;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: visible;
            height: 100%;
            position: relative;
        }

        /* Title Screen */
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #titleScreen h1 {
            color: white;
            font-size: 3rem;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #titleScreen p {
            color: white;
            font-size: 1.2rem;
            margin-bottom: 3rem;
            text-align: center;
        }

        .animal-selection {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 800px;
        }

        .animal-card {
            background: rgba(255,255,255,0.1);
            border: 3px solid transparent;
            border-radius: 15px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 120px;
            text-align: center;
        }

        .animal-card:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-5px);
        }

        .animal-card.selected {
            border-color: #00ff88;
            background: rgba(0,255,136,0.2);
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        .animal-card h3 {
            color: white;
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        .animal-card p {
            color: rgba(255,255,255,0.8);
            font-size: 0.8rem;
            margin: 0;
        }

        .start-btn {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.5;
            pointer-events: none;
        }

        .start-btn.enabled {
            opacity: 1;
            pointer-events: all;
        }

        .start-btn:hover.enabled {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,255,136,0.4);
        }

        /* Game Screen */
        #gameScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            cursor: crosshair;
            position: relative;
            z-index: 1;
        }

        /* 3D Models Container */
        #modelsContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .unit-model {
            position: absolute;
            pointer-events: none;
            z-index: 15;
        }

        .unit-model model-viewer {
            width: 100%;
            height: 100%;
            --progress-bar-display: none;
        }

        .unit-model.selected model-viewer {
            filter: drop-shadow(0 0 10px #00ff88);
        }

        /* UI Elements */
        .ui-panel {
            position: absolute;
            background: rgba(0,0,0,0.8);
            border-radius: 10px;
            padding: 1rem;
            color: white;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        #resourcePanel {
            top: 20px;
            left: 20px;
        }

        #controlPanel {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
        }

        .animal-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 0.5rem 1rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .animal-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.5);
        }

        .animal-btn.active {
            background: rgba(0,255,136,0.3);
            border-color: #00ff88;
        }

        #selectionBox {
            position: absolute;
            border: 2px dashed #00ff88;
            background: rgba(0,255,136,0.1);
            pointer-events: none;
            display: none;
            z-index: 50;
        }

        /* Mini-map */
        #miniMap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
        }

        /* Loading indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            z-index: 1001;
        }
    </style>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
</head>
<body>
    <!-- Title Screen -->
    <div id="titleScreen">
        <h1>üéÆ Animal RTS</h1>
        <p>Choose 3 animals to build your army and conquer the battlefield!</p>
        
        <div class="animal-selection">
            <div class="animal-card" data-animal="bear">
                <h3>üêª Bear</h3>
                <p>Strong & Durable<br>Slow but powerful units</p>
            </div>
            <div class="animal-card" data-animal="bee">
                <h3>üêù Bee</h3>
                <p>Fast & Agile<br>Quick swarm attacks</p>
            </div>
            <div class="animal-card" data-animal="turtle">
                <h3>üê¢ Turtle</h3>
                <p>Defensive<br>High armor, steady advance</p>
            </div>
            <div class="animal-card" data-animal="fox">
                <h3>ü¶ä Fox</h3>
                <p>Cunning & Quick<br>Hit and run tactics</p>
            </div>
            <div class="animal-card" data-animal="frog">
                <h3>üê∏ Frog</h3>
                <p>Amphibious<br>Can cross water</p>
            </div>
            <div class="animal-card" data-animal="owl">
                <h3>ü¶â Owl</h3>
                <p>Air Support<br>Flying reconnaissance</p>
            </div>
            <div class="animal-card" data-animal="pig">
                <h3>üê∑ Pig</h3>
                <p>Resource Gatherer<br>Boosts economy</p>
            </div>
            <div class="animal-card" data-animal="cat">
                <h3>üê± Cat</h3>
                <p>Stealth Hunter<br>Invisible attacks</p>
            </div>
            <div class="animal-card" data-animal="chicken">
                <h3>üêî Chicken</h3>
                <p>Rapid Breeder<br>Fast unit production</p>
            </div>
            <div class="animal-card" data-animal="dolphin">
                <h3>üê¨ Dolphin</h3>
                <p>Naval Unit<br>Controls waterways</p>
            </div>
        </div>
        
        <button class="start-btn" id="startBtn">Start Game</button>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen">
        <canvas id="gameCanvas"></canvas>
        
        <!-- 3D Models Container -->
        <div id="modelsContainer"></div>
        
        <!-- UI Panels -->
        <div id="resourcePanel" class="ui-panel">
            <div>Population: <span id="population">0</span>/<span id="populationCap">100</span></div>
            <div>Selected: <span id="selectedCount">0</span></div>
        </div>

        <div id="controlPanel" class="ui-panel">
            <!-- Animal control buttons will be dynamically added here -->
        </div>

        <div id="miniMap" class="ui-panel">
            <canvas id="miniMapCanvas" width="200" height="150"></canvas>
        </div>

        <div id="selectionBox"></div>
    </div>

    <div class="loading" id="loadingIndicator" style="display: none;">Loading 3D Models...</div>

    <script>
        // Game State
        let gameState = {
            selectedAnimals: [],
            units: [],
            bases: [],
            selectedUnits: [],
            gameStarted: false,
            population: 0,
            lastSpawnTime: 0,
            camera: { x: 0, y: 0 },
            isSelecting: false,
            selectionStart: { x: 0, y: 0 },
            mapSize: { width: 2000, height: 1500 },
            modelsLoaded: false,
            tiles: [],
            populationCap: 100
        };

        // Animal configurations with 3D model paths
        const animalConfigs = {
            bear: { speed: 1, size: 40, model: 'models/Bear.glb', baseStyle: 'cave', emoji: 'üêª' },
            bee: { speed: 3, size: 20, model: 'models/Bee.glb', baseStyle: 'hive', emoji: 'üêù' },
            turtle: { speed: 0.5, size: 35, model: 'models/Turtle.glb', baseStyle: 'pond', emoji: 'üê¢' },
            fox: { speed: 2.5, size: 25, model: 'models/Fox.glb', baseStyle: 'den', emoji: 'ü¶ä' },
            frog: { speed: 2, size: 22, model: 'models/Frog.glb', baseStyle: 'lily', emoji: 'üê∏' },
            owl: { speed: 2, size: 30, model: 'models/Owl.glb', baseStyle: 'tree', emoji: 'ü¶â' },
            pig: { speed: 1.5, size: 28, model: 'models/Pig.glb', baseStyle: 'pen', emoji: 'üê∑' },
            cat: { speed: 2.2, size: 24, model: 'models/cat.glb', baseStyle: 'house', emoji: 'üê±' },
            chicken: { speed: 1.8, size: 20, model: 'models/Chicken.glb', baseStyle: 'coop', emoji: 'üêî' },
            dolphin: { speed: 2.5, size: 38, model: 'models/dolphin.glb', baseStyle: 'pool', emoji: 'üê¨' }
        };

        // Hex tile system with proper offset rows
        const HEX_SIZE = 30;
        const HEX_WIDTH = HEX_SIZE * 2;
        const HEX_HEIGHT = Math.sqrt(3) * HEX_SIZE;
        
        const TileType = {
            mountain: 'mountain',
            lake: 'lake', 
            river: 'river',
            ocean: 'ocean',
            farmland: 'farmland',
            wetland: 'wetland',
            plain: 'plain'
        };

        const tileColors = {
            [TileType.mountain]: '#7d7d7d',
            [TileType.lake]: '#3ca0ff',
            [TileType.river]: '#3cb6ff', 
            [TileType.ocean]: '#2c79ff',
            [TileType.farmland]: '#d7c07c',
            [TileType.wetland]: '#55c06b',
            [TileType.plain]: '#88c464'
        };

        // Convert hex grid coordinates to pixel position (offset rows)
        function hexToPixel(col, row) {
            const x = col * HEX_WIDTH * 0.75;
            const y = row * HEX_HEIGHT + (col % 2) * (HEX_HEIGHT / 2);
            return { x, y };
        }

        // Find hex tile at pixel coordinates
        function pixelToHex(x, y) {
            // Approximate grid position
            const col = Math.round(x / (HEX_WIDTH * 0.75));
            const row = Math.round((y - (col % 2) * (HEX_HEIGHT / 2)) / HEX_HEIGHT);
            return { col, row };
        }

        // Draw hexagon at position
        function drawHex(ctx, x, y, size, fillStyle) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                const hx = x + Math.cos(angle) * size;
                const hy = y + Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(hx, hy);
                else ctx.lineTo(hx, hy);
            }
            ctx.closePath();
            ctx.fillStyle = fillStyle;
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }

        // Generate procedural hex map
        function createHexMap() {
            const tiles = [];
            const cols = Math.ceil(gameState.mapSize.width / (HEX_WIDTH * 0.75)) + 2;
            const rows = Math.ceil(gameState.mapSize.height / HEX_HEIGHT) + 2;
            
            // First pass: generate base terrain
            for (let col = 0; col < cols; col++) {
                for (let row = 0; row < rows; row++) {
                    const pos = hexToPixel(col, row);
                    if (pos.x < -HEX_SIZE || pos.y < -HEX_SIZE || 
                        pos.x > gameState.mapSize.width + HEX_SIZE || 
                        pos.y > gameState.mapSize.height + HEX_SIZE) continue;
                    
                    let type = TileType.plain;
                    const rand = Math.random();
                    
                    if (rand < 0.08) type = TileType.mountain;
                    else if (rand < 0.15) type = TileType.lake;
                    else if (rand < 0.20) type = TileType.farmland; 
                    else if (rand < 0.28) type = TileType.wetland;
                    
                    tiles.push({
                        col, row, type,
                        x: pos.x, y: pos.y,
                        assigned: false, // for farmland assignment
                        farmer: null
                    });
                }
            }
            
            // Second pass: convert lake clusters to rivers/oceans
            processLakeClusters(tiles);
            
            gameState.tiles = tiles;
        }

        // Convert connected lakes into rivers (2-9) or oceans (10+)
        function processLakeClusters(tiles) {
            const visited = new Set();
            const getKey = (col, row) => `${col},${row}`;
            
            tiles.forEach(tile => {
                if (tile.type !== TileType.lake || visited.has(getKey(tile.col, tile.row))) return;
                
                // Find connected lake cluster using BFS
                const cluster = [];
                const queue = [tile];
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    const key = getKey(current.col, current.row);
                    
                    if (visited.has(key)) continue;
                    visited.add(key);
                    cluster.push(current);
                    
                    // Check 6 hex neighbors (offset grid)
                    const neighbors = getHexNeighbors(current.col, current.row);
                    neighbors.forEach(({col, row}) => {
                        const neighbor = tiles.find(t => t.col === col && t.row === row);
                        if (neighbor && neighbor.type === TileType.lake && !visited.has(getKey(col, row))) {
                            queue.push(neighbor);
                        }
                    });
                }
                
                // Classify cluster by size
                if (cluster.length >= 10) {
                    cluster.forEach(t => t.type = TileType.ocean);
                } else if (cluster.length >= 2) {
                    cluster.forEach(t => t.type = TileType.river);
                }
            });
        }

        // Get 6 neighboring hex coordinates (accounting for offset rows)
        function getHexNeighbors(col, row) {
            const isEvenCol = col % 2 === 0;
            const neighbors = [];
            
            if (isEvenCol) {
                neighbors.push(
                    {col: col - 1, row: row - 1}, // top-left
                    {col: col, row: row - 1},     // top
                    {col: col + 1, row: row - 1}, // top-right
                    {col: col + 1, row: row},     // bottom-right
                    {col: col, row: row + 1},     // bottom
                    {col: col - 1, row: row}      // bottom-left
                );
            } else {
                neighbors.push(
                    {col: col - 1, row: row},     // top-left
                    {col: col, row: row - 1},     // top
                    {col: col + 1, row: row},     // top-right
                    {col: col + 1, row: row + 1}, // bottom-right
                    {col: col, row: row + 1},     // bottom
                    {col: col - 1, row: row + 1}  // bottom-left
                );
            }
            
            return neighbors;
        }

        // Get tile at pixel coordinates
        function getTileAt(x, y) {
            if (!gameState.tiles) return TileType.plain;
            
            let closest = null;
            let minDist = Infinity;
            
            gameState.tiles.forEach(tile => {
                const dist = Math.hypot(tile.x - x, tile.y - y);
                if (dist < HEX_SIZE && dist < minDist) {
                    closest = tile;
                    minDist = dist;
                }
            });
            
            return closest ? closest.type : TileType.plain;
        }

        // Check if animal can traverse tile type
        function canTraverse(animal, tileType) {
            switch (tileType) {
                case TileType.mountain:
                    return animal === 'bee' || animal === 'owl';
                case TileType.lake:
                    return animal === 'frog' || animal === 'turtle' || animal === 'dolphin';
                case TileType.river:
                    return animal === 'dolphin';
                case TileType.ocean:
                    return animal === 'dolphin';
                default:
                    return true; // farmland, wetland, plain
            }
        }

        // Get speed multiplier for animal on tile type
        function getSpeedMultiplier(animal, tileType) {
            if (tileType === TileType.wetland && (animal === 'frog' || animal === 'turtle')) {
                return 1.5;
            }
            return 1.0;
        }

        // Title Screen Logic
        document.addEventListener('DOMContentLoaded', function() {
            const animalCards = document.querySelectorAll('.animal-card');
            const startBtn = document.getElementById('startBtn');

            animalCards.forEach(card => {
                card.addEventListener('click', function() {
                    const animal = this.dataset.animal;
                    
                    if (this.classList.contains('selected')) {
                        this.classList.remove('selected');
                        gameState.selectedAnimals = gameState.selectedAnimals.filter(a => a !== animal);
                    } else if (gameState.selectedAnimals.length < 3) {
                        this.classList.add('selected');
                        gameState.selectedAnimals.push(animal);
                    }

                    // Update start button
                    if (gameState.selectedAnimals.length === 3) {
                        startBtn.classList.add('enabled');
                        startBtn.textContent = `Start with ${gameState.selectedAnimals.map(a => animalConfigs[a].emoji).join(' ')}`;
                    } else {
                        startBtn.classList.remove('enabled');
                        startBtn.textContent = `Select ${3 - gameState.selectedAnimals.length} more animals`;
                    }
                });
            });

            startBtn.addEventListener('click', function() {
                if (gameState.selectedAnimals.length === 3) {
                    startGame();
                }
            });
        });

        function startGame() {
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            document.getElementById('loadingIndicator').style.display = 'block';
            gameState.gameStarted = true;

            // Preload models then initialize game
            preloadModels().then(() => {
                document.getElementById('loadingIndicator').style.display = 'none';
                initializeGame();
                gameLoop();
            });
        }

        async function preloadModels() {
            const modelsToLoad = gameState.selectedAnimals.map(animal => animalConfigs[animal].model);
            
            // Create invisible model-viewers to preload
            const preloadContainer = document.createElement('div');
            preloadContainer.style.position = 'absolute';
            preloadContainer.style.top = '-1000px';
            preloadContainer.style.left = '-1000px';
            document.body.appendChild(preloadContainer);

            const loadPromises = modelsToLoad.map(modelPath => {
                return new Promise((resolve, reject) => {
                    const modelViewer = document.createElement('model-viewer');
                    modelViewer.src = modelPath;
                    modelViewer.style.width = '1px';
                    modelViewer.style.height = '1px';
                    
                    modelViewer.addEventListener('load', () => {
                        resolve();
                    });
                    
                    modelViewer.addEventListener('error', () => {
                        console.warn(`Failed to load model: ${modelPath}`);
                        resolve(); // Continue even if model fails to load
                    });
                    
                    preloadContainer.appendChild(modelViewer);
                    
                    // Timeout fallback
                    setTimeout(() => resolve(), 3000);
                });
            });

            await Promise.all(loadPromises);
            document.body.removeChild(preloadContainer);
            gameState.modelsLoaded = true;
        }

        function initializeGame() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Generate hex terrain map
            createHexMap();

            // Create bases for selected animals
            gameState.selectedAnimals.forEach((animal, index) => {
                const base = {
                    animal: animal,
                    team: 'player',
                    x: 200 + (index * 150),
                    y: 200,
                    lastSpawn: 0,
                    spawnInterval: 15000, // 15 seconds
                    size: 40
                };
                gameState.bases.push(base);
            });

            // Create enemy bases with 3 random remaining animals
            const remainingAnimals = Object.keys(animalConfigs).filter(a => !gameState.selectedAnimals.includes(a));
            // Shuffle simple
            for (let i = remainingAnimals.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [remainingAnimals[i], remainingAnimals[j]] = [remainingAnimals[j], remainingAnimals[i]];
            }
            const enemyAnimals = remainingAnimals.slice(0, 3);

            enemyAnimals.forEach((animal, index) => {
                const base = {
                    animal: animal,
                    team: 'enemy',
                    x: gameState.mapSize.width - (200 + (index * 150)),
                    y: gameState.mapSize.height - 200,
                    lastSpawn: 0,
                    spawnInterval: 15000,
                    size: 40
                };
                gameState.bases.push(base);
            });

            // Create control buttons
            createControlButtons();

            // Add event listeners
            setupEventListeners();
        }

        function createControlButtons() {
            const controlPanel = document.getElementById('controlPanel');
            controlPanel.innerHTML = '';

            gameState.selectedAnimals.forEach(animal => {
                const btn = document.createElement('button');
                btn.className = 'animal-btn';
                btn.textContent = `Select All ${animalConfigs[animal].emoji}`;
                btn.dataset.animal = animal;
                btn.addEventListener('click', () => selectAllUnitsOfType(animal));
                controlPanel.appendChild(btn);
            });
        }

        function setupEventListeners() {
            const canvas = document.getElementById('gameCanvas');

            // Mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);

            // Window resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                updateUnitModelPositions();
            });
        }

        function handleMouseDown(e) {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left + gameState.camera.x;
            const y = e.clientY - rect.top + gameState.camera.y;

            if (e.button === 0) { // Left click
                startSelection(x, y);
            } else if (e.button === 2) { // Right click
                // Check if right-clicking on farmland with single unit selected
                if (gameState.selectedUnits.length === 1) {
                    const clickedTile = gameState.tiles?.find(tile => 
                        Math.hypot(tile.x - x, tile.y - y) < HEX_SIZE
                    );
                    
                    if (clickedTile && clickedTile.type === TileType.farmland && !clickedTile.assigned) {
                        // Assign unit to farm this tile
                        const unit = gameState.selectedUnits[0];
                        clickedTile.assigned = true;
                        clickedTile.farmer = unit;
                        unit.farming = true;
                        unit.farmTile = clickedTile;
                        unit.targetX = clickedTile.x;
                        unit.targetY = clickedTile.y;
                        unit.isMoving = true;
                        gameState.populationCap += 3;
                        updateSelectedCount();
                        return;
                    }
                }
                
                moveSelectedUnits(x, y);
            }
        }

        function handleMouseMove(e) {
            if (gameState.isSelecting) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left + gameState.camera.x;
                const y = e.clientY - rect.top + gameState.camera.y;
                updateSelection(x, y);
            }
        }

        function handleMouseUp(e) {
            if (gameState.isSelecting) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left + gameState.camera.x;
                const y = e.clientY - rect.top + gameState.camera.y;
                finishSelection(x, y);
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = e.target.getBoundingClientRect();
            const x = touch.clientX - rect.left + gameState.camera.x;
            const y = touch.clientY - rect.top + gameState.camera.y;
            
            startSelection(x, y);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (gameState.isSelecting && e.touches.length === 1) {
                const touch = e.touches[0];
                const rect = e.target.getBoundingClientRect();
                const x = touch.clientX - rect.left + gameState.camera.x;
                const y = touch.clientY - rect.top + gameState.camera.y;
                updateSelection(x, y);
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (gameState.isSelecting) {
                if (e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    const rect = e.target.getBoundingClientRect();
                    const x = touch.clientX - rect.left + gameState.camera.x;
                    const y = touch.clientY - rect.top + gameState.camera.y;
                    finishSelection(x, y);
                }
            }
        }

        function startSelection(x, y) {
            // Check if clicking on a unit first
            const clickedUnit = gameState.units.find(unit => {
                const dx = unit.x - x;
                const dy = unit.y - y;
                return Math.sqrt(dx * dx + dy * dy) < unit.size;
            });

            if (clickedUnit) {
                // Single unit selection
                gameState.selectedUnits = [clickedUnit];
                updateSelectedCount();
                updateUnitSelectionVisuals();
            } else {
                // Start box selection
                gameState.isSelecting = true;
                gameState.selectionStart = { x, y };
                gameState.selectedUnits = [];
                updateSelectedCount();
                updateUnitSelectionVisuals();
            }
        }

        function updateSelection(x, y) {
            const selectionBox = document.getElementById('selectionBox');
            const canvas = document.getElementById('gameCanvas');
            
            const startX = Math.min(gameState.selectionStart.x - gameState.camera.x, x - gameState.camera.x);
            const startY = Math.min(gameState.selectionStart.y - gameState.camera.y, y - gameState.camera.y);
            const width = Math.abs(x - gameState.selectionStart.x);
            const height = Math.abs(y - gameState.selectionStart.y);

            selectionBox.style.left = startX + 'px';
            selectionBox.style.top = startY + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
            selectionBox.style.display = 'block';
        }

        function finishSelection(x, y) {
            gameState.isSelecting = false;
            document.getElementById('selectionBox').style.display = 'none';

            // Find units within selection box
            const minX = Math.min(gameState.selectionStart.x, x);
            const maxX = Math.max(gameState.selectionStart.x, x);
            const minY = Math.min(gameState.selectionStart.y, y);
            const maxY = Math.max(gameState.selectionStart.y, y);

            gameState.selectedUnits = gameState.units.filter(unit => 
                unit.team === 'player' &&
                unit.x >= minX && unit.x <= maxX && 
                unit.y >= minY && unit.y <= maxY
            );

            updateSelectedCount();
            updateUnitSelectionVisuals();
        }

        function moveSelectedUnits(x, y) {
            if (gameState.selectedUnits.length > 0) {
                // Filter out farming units - they can't be moved
                const movableUnits = gameState.selectedUnits.filter(unit => !unit.farming);
                if (movableUnits.length === 0) return;
                
                // Create formation around target point
                const formationRadius = Math.sqrt(movableUnits.length) * 20;
                
                movableUnits.forEach((unit, index) => {
                    const angle = (index / movableUnits.length) * Math.PI * 2;
                    const offsetX = Math.cos(angle) * formationRadius;
                    const offsetY = Math.sin(angle) * formationRadius;
                    
                    unit.targetX = x + offsetX;
                    unit.targetY = y + offsetY;
                    unit.isMoving = true;
                });
            }
        }

        function selectAllUnitsOfType(animalType) {
            gameState.selectedUnits = gameState.units.filter(unit => unit.animal === animalType && unit.team === 'player');
            updateSelectedCount();
            updateUnitSelectionVisuals();

            // Visual feedback
            const buttons = document.querySelectorAll('.animal-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-animal="${animalType}"]`).classList.add('active');
        }

        function createUnitModel(unit) {
            const modelContainer = document.createElement('div');
            modelContainer.className = 'unit-model';
            modelContainer.id = `unit-${unit.id}`;
            
            const modelViewer = document.createElement('model-viewer');
            modelViewer.src = animalConfigs[unit.animal].model;
            modelViewer.alt = `${unit.animal} unit`;
            modelViewer.autoRotate = false;
            modelViewer.cameraControls = false;
            modelViewer.disableZoom = true;
            modelViewer.rotationPerSecond = '0deg';
            modelViewer.style.width = (unit.size * 3) + 'px';
            modelViewer.style.height = (unit.size * 3) + 'px';
            
            // Fix camera and framing to prevent clipping
            modelViewer.cameraOrbit = '0deg 90deg 50m';
            modelViewer.fieldOfView = '10deg';
            modelViewer.minCameraOrbit = 'auto auto auto';
            modelViewer.maxCameraOrbit = 'auto auto auto';
            modelViewer.setAttribute('camera-target', 'auto auto auto');
            modelViewer.setAttribute('max-field-of-view', '45deg');
            modelViewer.setAttribute('min-field-of-view', '5deg');
            
            // Core model-viewer settings to prevent internal clipping
            modelViewer.setAttribute('auto-rotate-delay', '0');
            modelViewer.setAttribute('interaction-prompt', 'none');
            modelViewer.setAttribute('loading', 'eager');
            modelViewer.setAttribute('reveal', 'auto');
            
            // Wait for model to load then adjust framing
            modelViewer.addEventListener('load', () => {
                // Get the model's actual bounds and adjust camera accordingly
                setTimeout(() => {
                    try {
                        const center = modelViewer.getCameraTarget();
                        const bounds = modelViewer.getBoundingBoxCenter();
                        // Set camera far enough to see entire model
                        modelViewer.cameraOrbit = '0deg 75deg 100m';
                        modelViewer.fieldOfView = '15deg';
                    } catch (e) {
                        // Fallback if bounds calculation fails
                        modelViewer.cameraOrbit = '0deg 75deg 80m';
                        modelViewer.fieldOfView = '20deg';
                    }
                }, 100);
            });
            
            modelContainer.appendChild(modelViewer);
            document.getElementById('modelsContainer').appendChild(modelContainer);
            
            return modelContainer;
        }

        function spawnUnit(base) {
            const angle = Math.random() * Math.PI * 2;
            const distance = base.size + 30;
            
            const unit = {
                animal: base.animal,
                team: base.team,
                x: base.x + Math.cos(angle) * distance,
                y: base.y + Math.sin(angle) * distance,
                targetX: null,
                targetY: null,
                isMoving: false,
                size: animalConfigs[base.animal].size,
                speed: animalConfigs[base.animal].speed,
                id: Date.now() + Math.random(),
                modelElement: null,
                farming: false,
                farmTile: null
            };

            // Create 3D model for the unit
            unit.modelElement = createUnitModel(unit);
            
            gameState.units.push(unit);
            gameState.population++;
        }

        function updateUnits(deltaTime) {
            gameState.units.forEach(unit => {
                if (unit.isMoving && unit.targetX !== null && unit.targetY !== null) {
                    const dx = unit.targetX - unit.x;
                    const dy = unit.targetY - unit.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 5) {
                        // Check current tile for speed bonus
                        const currentTile = getTileAt(unit.x, unit.y);
                        const speedMultiplier = getSpeedMultiplier(unit.animal, currentTile);
                        const effectiveSpeed = unit.speed * speedMultiplier;
                        
                        const moveX = (dx / distance) * effectiveSpeed;
                        const moveY = (dy / distance) * effectiveSpeed;
                        
                        // Check if next position is traversable
                        const nextTile = getTileAt(unit.x + moveX, unit.y + moveY);
                        if (!canTraverse(unit.animal, nextTile)) {
                            unit.isMoving = false;
                            unit.targetX = null;
                            unit.targetY = null;
                            return;
                        }
                        
                        unit.x += moveX;
                        unit.y += moveY;
                        
                        // Rotate model to face movement direction (rotate the model, not the camera)
                        if (unit.modelElement) {
                            const angleRad = Math.atan2(dy, dx); // radians
                            const angleDeg = (angleRad * 180 / Math.PI);
                            const modelViewer = unit.modelElement.querySelector('model-viewer');
                            if (modelViewer) {
                                // Adjust yaw so that the model front aligns with motion direction.
                                // Most GLB exports have the model facing the -Z axis; offset by +90 deg.
                                const yaw = -(angleDeg - 90); // Negate for correct handedness & offset
                                modelViewer.setAttribute('rotation', `0deg ${yaw.toFixed(2)}deg 0deg`);
                            }
                        }
                    } else {
                        unit.isMoving = false;
                        unit.targetX = null;
                        unit.targetY = null;
                    }
                }

                if (unit.team === 'enemy' && !unit.isMoving) {
                    // Simple AI: move toward nearest player base
                    const playerBases = gameState.bases.filter(b => b.team === 'player');
                    if (playerBases.length > 0) {
                        let nearest = playerBases[0];
                        let nearestDist = Math.hypot(nearest.x - unit.x, nearest.y - unit.y);
                        playerBases.forEach(b => {
                            const d = Math.hypot(b.x - unit.x, b.y - unit.y);
                            if (d < nearestDist) {
                                nearest = b;
                                nearestDist = d;
                            }
                        });
                        unit.targetX = nearest.x;
                        unit.targetY = nearest.y;
                        unit.isMoving = true;
                    }
                }
            });
            
            updateUnitModelPositions();
        }

        function updateUnitModelPositions() {
            gameState.units.forEach(unit => {
                if (unit.modelElement) {
                    const modelSize = unit.size * 3; // Keep consistent with creation size
                    const screenX = unit.x - gameState.camera.x - modelSize/2;
                    const screenY = unit.y - gameState.camera.y - modelSize/2;
                    
                    unit.modelElement.style.left = screenX + 'px';
                    unit.modelElement.style.top = screenY + 'px';
                    // Don't resize - maintain original size to prevent clipping
                    // unit.modelElement.style.width = modelSize + 'px';
                    // unit.modelElement.style.height = modelSize + 'px';
                }
            });
        }

        function updateUnitSelectionVisuals() {
            gameState.units.forEach(unit => {
                if (unit.modelElement) {
                    if (gameState.selectedUnits.includes(unit)) {
                        unit.modelElement.classList.add('selected');
                    } else {
                        unit.modelElement.classList.remove('selected');
                    }
                }
            });
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = gameState.selectedUnits.length;
            document.getElementById('population').textContent = gameState.population;
            document.getElementById('populationCap').textContent = gameState.populationCap;
        }

        function render() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Save context for camera transform
            ctx.save();
            ctx.translate(-gameState.camera.x, -gameState.camera.y);

            // Draw bases
            gameState.bases.forEach(base => {
                const config = animalConfigs[base.animal];
                
                // Base structure
                ctx.fillStyle = '#4a4a4a';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                
                // Different base shapes based on animal
                if (config.baseStyle === 'hive') {
                    drawHexagon(ctx, base.x, base.y, base.size);
                } else if (config.baseStyle === 'pond') {
                    ctx.beginPath();
                    ctx.arc(base.x, base.y, base.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.fillRect(base.x - base.size/2, base.y - base.size/2, base.size, base.size);
                    ctx.strokeRect(base.x - base.size/2, base.y - base.size/2, base.size, base.size);
                }

                // Base emoji
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#fff';
                ctx.fillText(config.emoji, base.x, base.y + 8);
            });

            // Draw movement target indicators for selected units
            gameState.selectedUnits.forEach(unit => {
                if (unit.isMoving && unit.targetX && unit.targetY) {
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(unit.x, unit.y);
                    ctx.lineTo(unit.targetX, unit.targetY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Target marker
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.arc(unit.targetX, unit.targetY, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw hex terrain tiles
            if (gameState.tiles) {
                gameState.tiles.forEach(tile => {
                    drawHex(ctx, tile.x, tile.y, HEX_SIZE, tileColors[tile.type]);
                    
                    // Draw assignment indicator for farmland
                    if (tile.type === TileType.farmland && tile.assigned) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('ÔøΩÔøΩ', tile.x, tile.y + 5);
                    }
                });
            }

            ctx.restore();

            // Draw mini-map
            renderMiniMap();
        }

        function drawHexagon(ctx, x, y, size) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                const px = x + Math.cos(angle) * size;
                const py = y + Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function renderMiniMap() {
            const miniCanvas = document.getElementById('miniMapCanvas');
            const miniCtx = miniCanvas.getContext('2d');
            
            // Clear mini-map
            miniCtx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);
            
            const scaleX = miniCanvas.width / gameState.mapSize.width;
            const scaleY = miniCanvas.height / gameState.mapSize.height;

            // Draw bases on mini-map
            gameState.bases.forEach(base => {
                miniCtx.fillStyle = '#4a4a4a';
                miniCtx.fillRect(
                    base.x * scaleX - 2, 
                    base.y * scaleY - 2, 
                    4, 4
                );
            });

            // Draw units on mini-map
            gameState.units.forEach(unit => {
                miniCtx.fillStyle = gameState.selectedUnits.includes(unit) ? '#00ff88' : '#ffffff';
                miniCtx.fillRect(
                    unit.x * scaleX - 1, 
                    unit.y * scaleY - 1, 
                    2, 2
                );
            });

            // Draw terrain on mini-map
            if (gameState.tiles) {
                gameState.tiles.forEach(tile => {
                    miniCtx.fillStyle = tileColors[tile.type];
                    const mx = tile.x * scaleX;
                    const my = tile.y * scaleY;
                    miniCtx.fillRect(mx - 1, my - 1, 2, 2);
                });
            }

            // Draw camera view
            const cameraX = gameState.camera.x * scaleX;
            const cameraY = gameState.camera.y * scaleY;
            const cameraW = window.innerWidth * scaleX;
            const cameraH = window.innerHeight * scaleY;
            
            miniCtx.strokeStyle = '#fff';
            miniCtx.lineWidth = 1;
            miniCtx.strokeRect(cameraX, cameraY, cameraW, cameraH);
        }

        function gameLoop() {
            if (!gameState.gameStarted) return;

            const currentTime = Date.now();
            const deltaTime = currentTime - (gameState.lastTime || currentTime);
            gameState.lastTime = currentTime;

            // Spawn units from bases
            gameState.bases.forEach(base => {
                if (currentTime - base.lastSpawn > base.spawnInterval) {
                    spawnUnit(base);
                    base.lastSpawn = currentTime;
                }
            });

            // Update units
            updateUnits(deltaTime);

            // Render
            render();

            // Continue game loop
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html> 