<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animal RTS - Choose Your Army</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow: visible;
            height: 100%;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: visible;
            height: 100%;
            position: relative;
        }

        /* Title Screen */
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #titleScreen h1 {
            color: white;
            font-size: 3rem;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #titleScreen p {
            color: white;
            font-size: 1.2rem;
            margin-bottom: 3rem;
            text-align: center;
        }

        .animal-selection {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 800px;
        }

        .animal-card {
            background: rgba(255,255,255,0.1);
            border: 3px solid transparent;
            border-radius: 15px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 120px;
            text-align: center;
        }

        .animal-card:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-5px);
        }

        .animal-card.selected {
            border-color: #00ff88;
            background: rgba(0,255,136,0.2);
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        .animal-card h3 {
            color: white;
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        .animal-card p {
            color: rgba(255,255,255,0.8);
            font-size: 0.8rem;
            margin: 0;
        }

        .start-btn {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.5;
            pointer-events: none;
        }

        .start-btn.enabled {
            opacity: 1;
            pointer-events: all;
        }

        .start-btn:hover.enabled {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,255,136,0.4);
        }

        /* Game Screen */
        #gameScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            cursor: crosshair;
            position: relative;
            z-index: 1;
        }

        /* 3D Models Container */
        #modelsContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .unit-model {
            position: absolute;
            pointer-events: none;
            z-index: 15;
        }

        .unit-model model-viewer {
            width: 100%;
            height: 100%;
            --progress-bar-display: none;
        }

        .unit-model.selected model-viewer {
            filter: drop-shadow(0 0 10px #00ff88);
        }

        /* Hex Grid Terrain System */
        #hexGridContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            opacity: 0.8;
        }

        #hex-grid {
            position: absolute;
            top: 50px;
            left: 50px;
            width: 100%;
            height: 100%;
            --hex-tile-size: 180px; /* Tripled from 60px */
            /* Enhanced 3D support for terrain heights */
            transform-style: preserve-3d;
            perspective: 2000px;
            perspective-origin: center center;
            transform-origin: center center;
        }

        /* Removed rotation - all tiles maintain same orientation */

        .hex-tile {
            background: transparent;
            border: none;
            --progress-bar-display: none;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Performance optimizations */
            will-change: transform;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            transition: transform 0.2s ease;
            /* Create hexagonal shape using clip-path - larger hexagon for tighter gaps */
            clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
        }

        .hex-tile:hover {
            transform: scale(1.05);
            z-index: 10;
        }

        /* Static tile styling - now all tiles are 3D models */
        .hex-tile.mountain {
            filter: brightness(0.9); /* Slightly darker for visual distinction */
        }

        .hex-tile.hill {
            filter: brightness(0.95); /* Slightly darker for visual distinction */
        }

        .hex-tile:hover {
            filter: brightness(1.1) saturate(1.2); /* Highlight on hover */
        }

        /* Visual feedback for terrain traversability */
        .hex-tile.non-traversable {
            cursor: not-allowed;
        }

        .hex-tile.traversable {
            cursor: pointer;
        }

        .hex-tile model-viewer {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }

        /* 3D Terrain System */
        .tile-3d-container {
            transform-style: preserve-3d;
        }

        .terrain-plane {
            transform-style: preserve-3d;
            backface-visibility: visible;
        }

        .base-plane {
            opacity: 0.8;
        }

        /* Enhanced 3D terrain colors with gradients */
        .tile-3d-container.mountain .terrain-plane {
            background: linear-gradient(45deg, #666666, #888888) !important;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }

        .tile-3d-container.hill .terrain-plane {
            background: linear-gradient(45deg, #8B7355, #A0845C) !important;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.2);
        }

        .tile-3d-container.forest .terrain-plane {
            background: linear-gradient(45deg, #228B22, #32CD32) !important;
            box-shadow: inset 0 0 6px rgba(0,0,0,0.2);
        }

        .tile-3d-container.farmland .terrain-plane {
            background: linear-gradient(45deg, #8B4513, #A0522D) !important;
            box-shadow: inset 0 0 4px rgba(0,0,0,0.1);
        }

        /* UI Elements */
        .ui-panel {
            position: absolute;
            background: rgba(0,0,0,0.8);
            border-radius: 10px;
            padding: 1rem;
            color: white;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        #resourcePanel {
            top: 20px;
            left: 20px;
        }

        #controlPanel {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
        }

        .animal-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 0.5rem 1rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .animal-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.5);
        }

        .animal-btn.active {
            background: rgba(0,255,136,0.3);
            border-color: #00ff88;
        }

        #selectionBox {
            position: absolute;
            border: 2px dashed #00ff88;
            background: rgba(0,255,136,0.1);
            pointer-events: none;
            display: none;
            z-index: 50;
        }

        /* Mini-map */
        #miniMap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
        }

        /* Loading indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            z-index: 1001;
        }

        /* Development Control Panel */
        #devPanel {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 8px;
            color: white;
            z-index: 1001;
            width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            transition: transform 0.3s ease;
            border: 2px solid #00ff88;
        }

        #devPanel.collapsed {
            transform: translateX(305px);
        }

        #devPanel h3 {
            margin: 0 0 10px 0;
            color: #00ff88;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
            font-size: 14px;
        }

        .dev-section {
            margin-bottom: 15px;
            border: 1px solid #333;
            padding: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.05);
        }

        .dev-control {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 5px 0;
            padding: 2px 0;
        }

        .dev-control label {
            flex: 1;
            font-size: 11px;
            min-width: 80px;
        }

        .dev-control input[type="range"] {
            flex: 1;
            margin: 0 8px;
            min-width: 80px;
        }

        .dev-control .value {
            width: 50px;
            text-align: right;
            font-size: 10px;
            color: #00ff88;
            font-weight: bold;
        }

        .dev-control input[type="checkbox"] {
            margin-left: 8px;
            transform: scale(1.2);
        }

        .dev-control button {
            padding: 4px 8px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            margin-left: 4px;
        }

        .dev-control button:hover {
            background: #555;
            border-color: #00ff88;
        }

        #devToggle {
            position: fixed;
            top: 15px;
            right: 15px;
            background: #00ff88;
            color: black;
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            cursor: pointer;
            z-index: 1002;
            font-weight: bold;
            font-size: 16px;
        }

        #devToggle:hover {
            background: #00cc66;
            transform: scale(1.1);
        }
    </style>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
</head>
<body>
    <!-- Title Screen -->
    <div id="titleScreen">
        <h1>🎮 Animal RTS</h1>
        <p>Choose 3 animals to build your army and conquer the battlefield!</p>
        
        <div class="animal-selection">
            <div class="animal-card" data-animal="bear">
                <h3>🐻 Bear</h3>
                <p>Strong & Durable<br>Slow but powerful units</p>
            </div>
            <div class="animal-card" data-animal="bee">
                <h3>🐝 Bee</h3>
                <p>Fast & Agile<br>Quick swarm attacks</p>
            </div>
            <div class="animal-card" data-animal="turtle">
                <h3>🐢 Turtle</h3>
                <p>Defensive<br>High armor, steady advance</p>
            </div>
            <div class="animal-card" data-animal="fox">
                <h3>🦊 Fox</h3>
                <p>Cunning & Quick<br>Hit and run tactics</p>
            </div>
            <div class="animal-card" data-animal="frog">
                <h3>🐸 Frog</h3>
                <p>Amphibious<br>Can cross water</p>
            </div>
            <div class="animal-card" data-animal="owl">
                <h3>🦉 Owl</h3>
                <p>Air Support<br>Flying reconnaissance</p>
            </div>
            <div class="animal-card" data-animal="pig">
                <h3>🐷 Pig</h3>
                <p>Resource Gatherer<br>Boosts economy</p>
            </div>
            <div class="animal-card" data-animal="cat">
                <h3>🐱 Cat</h3>
                <p>Stealth Hunter<br>Invisible attacks</p>
            </div>
            <div class="animal-card" data-animal="chicken">
                <h3>🐔 Chicken</h3>
                <p>Rapid Breeder<br>Fast unit production</p>
            </div>
            <div class="animal-card" data-animal="dolphin">
                <h3>🐬 Dolphin</h3>
                <p>Naval Unit<br>Controls waterways</p>
            </div>
        </div>
        
        <button class="start-btn" id="startBtn">Start Game</button>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen">
        <canvas id="gameCanvas"></canvas>
        
        <!-- 3D Models Container -->
        <div id="modelsContainer"></div>
        
        <!-- Hex Grid Terrain Container -->
        <div id="hexGridContainer">
            <div id="hex-grid"></div>
        </div>
        
        <!-- UI Panels -->
        <div id="resourcePanel" class="ui-panel">
            <div>Population: <span id="population">0</span></div>
            <div>Selected: <span id="selectedCount">0</span></div>
        </div>

        <div id="controlPanel" class="ui-panel">
            <!-- Animal control buttons will be dynamically added here -->
        </div>

        <div id="miniMap" class="ui-panel">
            <canvas id="miniMapCanvas" width="200" height="150"></canvas>
        </div>

        <div id="selectionBox"></div>
    </div>

    <!-- Development Control Panel -->
    <button id="devToggle">⚙</button>
    <div id="devPanel" class="collapsed">
        <h3>🛠 Development Controls</h3>
        
        <!-- Camera Controls -->
        <div class="dev-section">
            <h4 style="margin: 0 0 8px 0; color: #ffaa00;">📹 Camera Controls</h4>
            <div class="dev-control">
                <label>Global Camera X:</label>
                <input type="range" id="globalCameraX" min="-2000" max="2000" value="0">
                <span class="value" id="globalCameraXValue">0</span>
            </div>
            <div class="dev-control">
                <label>Global Camera Y:</label>
                <input type="range" id="globalCameraY" min="-2000" max="2000" value="0">
                <span class="value" id="globalCameraYValue">0</span>
            </div>
            <div class="dev-control">
                <label>Global Zoom:</label>
                <input type="range" id="globalCameraZoom" min="0.1" max="3" step="0.1" value="1">
                <span class="value" id="globalCameraZoomValue">1x</span>
            </div>
            <div class="dev-control">
                <label>Global Rotation:</label>
                <input type="range" id="globalCameraRotation" min="-180" max="180" value="0">
                <span class="value" id="globalCameraRotationValue">0°</span>
            </div>
            <div class="dev-control">
                <label>Pitch (X-axis):</label>
                <input type="range" id="globalCameraPitch" min="-90" max="90" value="0">
                <span class="value" id="globalCameraPitchValue">0°</span>
            </div>
            <div class="dev-control">
                <label>Yaw (Y-axis):</label>
                <input type="range" id="globalCameraYaw" min="-180" max="180" value="0">
                <span class="value" id="globalCameraYawValue">0°</span>
            </div>
            <div class="dev-control">
                <label>Roll (Z-axis):</label>
                <input type="range" id="globalCameraRoll" min="-180" max="180" value="0">
                <span class="value" id="globalCameraRollValue">0°</span>
            </div>
            <div class="dev-control">
                <label>Tile Camera Orbit:</label>
                <input type="range" id="tileCameraOrbit" min="0" max="360" value="0">
                <span class="value" id="tileCameraOrbitValue">0°</span>
            </div>
            <div class="dev-control">
                <label>Tile Camera Elevation:</label>
                <input type="range" id="tileCameraElevation" min="0" max="90" value="75">
                <span class="value" id="tileCameraElevationValue">75°</span>
            </div>
            <div class="dev-control">
                <label>Tile Camera Distance:</label>
                <input type="range" id="tileCameraDistance" min="10" max="200" value="100">
                <span class="value" id="tileCameraDistanceValue">100m</span>
            </div>
        </div>

        <!-- Grid Controls -->
        <div class="dev-section">
            <h4 style="margin: 0 0 8px 0; color: #ffaa00;">🗺 Grid Controls</h4>
            <div class="dev-control">
                <label>Grid Columns:</label>
                <input type="range" id="gridCols" min="5" max="25" value="12">
                <span class="value" id="gridColsValue">12</span>
            </div>
            <div class="dev-control">
                <label>Grid Rows:</label>
                <input type="range" id="gridRows" min="5" max="25" value="16">
                <span class="value" id="gridRowsValue">16</span>
            </div>
            <div class="dev-control">
                <label>Tile Width:</label>
                <input type="range" id="tileWidth" min="30" max="150" value="90">
                <span class="value" id="tileWidthValue">90px</span>
            </div>
            <div class="dev-control">
                <label>Tile Height:</label>
                <input type="range" id="tileHeight" min="40" max="200" value="120">
                <span class="value" id="tileHeightValue">120px</span>
            </div>
            <div class="dev-control">
                <label>Hex Offset:</label>
                <input type="range" id="hexOffset" min="10" max="100" value="60">
                <span class="value" id="hexOffsetValue">60px</span>
            </div>
            <div class="dev-control">
                <label>Column Gap:</label>
                <input type="range" id="columnGap" min="-50" max="50" value="0">
                <span class="value" id="columnGapValue">0px</span>
            </div>
            <div class="dev-control">
                <label>Row Gap:</label>
                <input type="range" id="rowGap" min="-50" max="50" value="0">
                <span class="value" id="rowGapValue">0px</span>
            </div>
            <div class="dev-control">
                <button onclick="regenerateGrid()">🔄 Regenerate Grid</button>
            </div>
        </div>

        <!-- Terrain Height Controls -->
        <div class="dev-section">
            <h4 style="margin: 0 0 8px 0; color: #ffaa00;">🏔 Terrain Heights</h4>
            <div class="dev-control">
                <label>Mountain Height:</label>
                <input type="range" id="mountainHeight" min="50" max="200" value="120">
                <span class="value" id="mountainHeightValue">120px</span>
            </div>
            <div class="dev-control">
                <label>Hill Height:</label>
                <input type="range" id="hillHeight" min="30" max="150" value="80">
                <span class="value" id="hillHeightValue">80px</span>
            </div>
            <div class="dev-control">
                <label>Forest Height:</label>
                <input type="range" id="forestHeight" min="20" max="100" value="40">
                <span class="value" id="forestHeightValue">40px</span>
            </div>
            <div class="dev-control">
                <label>Farmland Height:</label>
                <input type="range" id="farmlandHeight" min="0" max="20" value="5">
                <span class="value" id="farmlandHeightValue">5px</span>
            </div>
            <div class="dev-control">
                <label>Height Multiplier:</label>
                <input type="range" id="heightMultiplier" min="0.1" max="3" step="0.1" value="1">
                <span class="value" id="heightMultiplierValue">1x</span>
            </div>
        </div>

        <!-- Unit Controls -->
        <div class="dev-section">
            <h4 style="margin: 0 0 8px 0; color: #ffaa00;">🐾 Unit Controls</h4>
            <div class="dev-control">
                <label>Unit Speed Multiplier:</label>
                <input type="range" id="unitSpeedMultiplier" min="0.1" max="5" step="0.1" value="1">
                <span class="value" id="unitSpeedMultiplierValue">1.0x</span>
            </div>
            <div class="dev-control">
                <label>Unit Size Multiplier:</label>
                <input type="range" id="unitSizeMultiplier" min="0.5" max="3" step="0.1" value="1">
                <span class="value" id="unitSizeMultiplierValue">1.0x</span>
            </div>
            <div class="dev-control">
                <label>Spawn Interval (sec):</label>
                <input type="range" id="spawnInterval" min="1" max="60" value="15">
                <span class="value" id="spawnIntervalValue">15s</span>
            </div>
            <div class="dev-control">
                <button onclick="clearAllUnits()">🗑 Clear Units</button>
                <button onclick="spawnTestUnits()">➕ Spawn Test</button>
            </div>
        </div>

        <!-- Population Controls -->
        <div class="dev-section">
            <h4 style="margin: 0 0 8px 0; color: #ffaa00;">📊 Population Controls</h4>
            <div class="dev-control">
                <label>Max Per Team:</label>
                <input type="range" id="maxPerTeam" min="10" max="200" value="99">
                <span class="value" id="maxPerTeamValue">99</span>
            </div>
            <div class="dev-control">
                <label>Max Per Animal:</label>
                <input type="range" id="maxPerAnimal" min="5" max="50" value="33">
                <span class="value" id="maxPerAnimalValue">33</span>
            </div>
            <div class="dev-control">
                <label>Enable Death Sim:</label>
                <input type="checkbox" id="enableDeathSim" checked>
            </div>
        </div>

        <!-- Debug Controls -->
        <div class="dev-section">
            <h4 style="margin: 0 0 8px 0; color: #ffaa00;">🐛 Debug Controls</h4>
            <div class="dev-control">
                <label>Show Collision Debug:</label>
                <input type="checkbox" id="showCollisionDebug">
            </div>
            <div class="dev-control">
                <label>Show Path Debug:</label>
                <input type="checkbox" id="showPathDebug">
            </div>
            <div class="dev-control">
                <label>Show Grid Debug:</label>
                <input type="checkbox" id="showGridDebug">
            </div>
            <div class="dev-control">
                <button onclick="exportSettings()">💾 Export</button>
                <button onclick="resetSettings()">🔄 Reset</button>
            </div>
        </div>
    </div>

    <div class="loading" id="loadingIndicator" style="display: none;">Loading 3D Models...</div>

    <script>
        // Game State
        let gameState = {
            selectedAnimals: [],
            units: [],
            bases: [],
            selectedUnits: [],
            gameStarted: false,
            population: 0,
            lastSpawnTime: 0,
            camera: { x: 0, y: 0 },
            isSelecting: false,
            selectionStart: { x: 0, y: 0 },
            mapSize: { width: 2000, height: 1500 },
            modelsLoaded: false,
            // Population management
            maxPopulationPerTeam: 99,
            maxUnitsPerAnimalType: 33,
            populationByTeam: { player: 0, enemy: 0 },
            populationByAnimal: {}
        };

        // Development Settings
        let devSettings = {
            globalCamera: { x: 0, y: 0, zoom: 1, rotation: 0, pitch: 0, yaw: 0, roll: 0 },
            tileCamera: { orbit: 0, elevation: 75, distance: 100 },
            grid: { 
                cols: 12, rows: 16, 
                tileWidth: 90, tileHeight: 120, 
                columnGap: 0, rowGap: 0, hexOffset: 60 
            },
            terrain: {
                mountainHeight: 120,
                hillHeight: 80,
                forestHeight: 40,
                farmlandHeight: 5,
                heightMultiplier: 1
            },
            units: { speedMultiplier: 1, sizeMultiplier: 1, spawnInterval: 15 },
            population: { maxPerTeam: 99, maxPerAnimal: 33, enableDeathSim: true },
            debug: { showCollision: false, showPath: false, showGrid: false }
        };

        // Animal configurations with 3D model paths
        const animalConfigs = {
            bear: { speed: 1, size: 40, model: 'models/Bear.glb', baseStyle: 'cave', emoji: '🐻' },
            bee: { speed: 3, size: 20, model: 'models/Bee.glb', baseStyle: 'hive', emoji: '🐝' },
            turtle: { speed: 0.5, size: 35, model: 'models/Turtle.glb', baseStyle: 'pond', emoji: '🐢' },
            fox: { speed: 2.5, size: 25, model: 'models/Fox.glb', baseStyle: 'den', emoji: '🦊' },
            frog: { speed: 2, size: 22, model: 'models/Frog.glb', baseStyle: 'lily', emoji: '🐸' },
            owl: { speed: 2, size: 30, model: 'models/Owl.glb', baseStyle: 'tree', emoji: '🦉' },
            pig: { speed: 1.5, size: 28, model: 'models/Pig.glb', baseStyle: 'pen', emoji: '🐷' },
            cat: { speed: 2.2, size: 24, model: 'models/cat.glb', baseStyle: 'house', emoji: '🐱' },
            chicken: { speed: 1.8, size: 20, model: 'models/Chicken.glb', baseStyle: 'coop', emoji: '🐔' },
            dolphin: { speed: 2.5, size: 38, model: 'models/dolphin.glb', baseStyle: 'pool', emoji: '🐬' }
        };

        /* --------------------
           Phase 0 – Ground-rules & Tile Legend (two-player map)
        ---------------------*/

        // Single source of truth for every terrain / base tile
        const TileType = Object.freeze({
            PLAYER_BASE:   'playerBase',   // b – will be bound to chosen animals later
            ENEMY_BASE:    'enemyBase',    // e – NPC bases
            MOUNTAIN:      'mountain',     // m
            LAKE:          'lake',         // l (clusters post-processed → river/ocean)
            RIVER:         'river',        // r
            OCEAN:         'ocean',        // o
            FARMLAND:      'farmland',     // f
            WETLAND:       'wetland',      // w
            PLAIN:         'plain'         // p (default)
        });

        // Mapping from CSV character to TileType for quick parsing (Phase 1 will use this)
        const TILE_CHAR = Object.freeze({
            'b': TileType.PLAYER_BASE,
            'e': TileType.ENEMY_BASE,
            'm': TileType.MOUNTAIN,
            'l': TileType.LAKE,
            'r': TileType.RIVER,
            'o': TileType.OCEAN,
            'f': TileType.FARMLAND,
            'w': TileType.WETLAND,
            'p': TileType.PLAIN,
            '':  TileType.PLAIN
        });

        // Two-team setup: human player vs single NPC (AI)
        const Teams = Object.freeze({
            PLAYER: 'player',
            NPC:    'enemy'   // retains previous naming for compatibility
        });

        // Hex grid terrain system
        const hexTileModels = [
            { file: 'models/Mountain.glb', alt: 'Mountain Tile' },
            { file: 'models/Forest.glb', alt: 'Forest Tile' },
            { file: 'models/Hill.glb', alt: 'Hill Tile' },
            { file: 'models/FarmLand.glb', alt: 'Farm Land Tile' }
        ];

        // Game map cache to avoid regeneration
        let gameMap = null;
                
                // Helper function to check if a tile is traversable by a specific animal
        function isTileTraversable(x, y, animalType = null) {
            if (!gameMap || x < 0 || y < 0 || x >= gameMap.length || y >= gameMap[0].length) {
                return false; // Out of bounds
            }
            
            const tile = gameMap[x][y];
            
            // Flying animals (Owl and Bee) can traverse all terrain including Mountains/Hills
            if (animalType === 'owl' || animalType === 'bee') {
                return true;
            }
            
            // Ground animals cannot traverse Mountains or Hills
            if (tile.file.includes('Mountain') || tile.file.includes('Hill')) {
                return false;
            }
            
            // All other terrain (FarmLand, Forest) is traversable by ground animals
            return true;
        }

        // Convert screen coordinates to hex grid coordinates with proper offset handling
        function screenToHex(x, y) {
            const hexWidth = devSettings.grid.tileWidth + devSettings.grid.columnGap;
            const hexHeight = devSettings.grid.tileHeight + devSettings.grid.rowGap;
            
            const hexX = Math.floor(x / hexWidth);
            let hexY = Math.floor(y / hexHeight);
            
            // Adjust for hex offset on odd columns
            if (hexX % 2 === 1) {
                hexY = Math.floor((y - devSettings.grid.hexOffset) / hexHeight);
            }
            
            return { x: hexX, y: hexY };
        }

        // Convert hex coordinates to screen coordinates (center of tile)
        function hexToScreen(hexX, hexY) {
            const hexWidth = devSettings.grid.tileWidth + devSettings.grid.columnGap;
            const hexHeight = devSettings.grid.tileHeight + devSettings.grid.rowGap;
            
            let screenX = hexX * hexWidth + devSettings.grid.tileWidth / 2; // Center of tile
            let screenY = hexY * hexHeight + devSettings.grid.tileHeight / 2; // Center of tile
            
            // Adjust for hex offset on odd columns
            if (hexX % 2 === 1) {
                screenY += devSettings.grid.hexOffset;
            }
            
            return { x: screenX, y: screenY };
        }

        // Check if a specific screen position is within a non-traversable hex tile
        function isPositionBlocked(screenX, screenY, animalType) {
            const hex = screenToHex(screenX, screenY);
            return !isTileTraversable(hex.x, hex.y, animalType);
        }

        // Get hex tile boundaries for collision detection
        function getHexBounds(hexX, hexY) {
            const center = hexToScreen(hexX, hexY);
            const size = 60; // Half of tile size (120/2)
            
            return {
                centerX: center.x,
                centerY: center.y,
                minX: center.x - size,
                maxX: center.x + size,
                minY: center.y - size,
                maxY: center.y + size,
                size: size
            };
        }

        // Check if a unit's 3D model would collide with non-traversable hex tile edges
        function checkHexCollision(unitX, unitY, animalType, unitSize = 15) {
            // Flying animals don't collide with terrain
            if (animalType === 'owl' || animalType === 'bee') {
                return false;
            }
            
            const currentHex = screenToHex(unitX, unitY);
            
            // Check current hex - if it's non-traversable, that's a collision
            if (!isTileTraversable(currentHex.x, currentHex.y, animalType)) {
                return true;
            }
            
            // More reasonable collision detection: only check close neighboring tiles
            const unitRadius = unitSize * 0.8; // Use 80% of unit size for more forgiving collision
            const hexRadius = 45; // Use 75% of hex radius (60 * 0.75) for tile edge detection
            
            // Get all neighboring hexes
            const neighbors = getNeighbors(currentHex.x, currentHex.y);
            
            for (const [neighborX, neighborY] of neighbors) {
                if (!isTileTraversable(neighborX, neighborY, animalType)) {
                    const neighborCenter = hexToScreen(neighborX, neighborY);
                    
                    // Calculate distance between unit center and tile center
                    const distance = Math.sqrt(
                        Math.pow(unitX - neighborCenter.x, 2) + 
                        Math.pow(unitY - neighborCenter.y, 2)
                    );
                    
                    // More reasonable collision: allow closer approach but still prevent overlap
                    // Only collision if unit would significantly overlap with the tile
                    const minSafeDistance = hexRadius + unitRadius * 0.5; // More forgiving distance
                    
                    if (distance < minSafeDistance) {
                        console.log(`🚫 Collision: ${animalType} at (${Math.round(unitX)}, ${Math.round(unitY)}) too close to ${getTileAt(neighborX, neighborY)?.terrainType} at (${neighborX}, ${neighborY}), distance: ${Math.round(distance)}, min: ${Math.round(minSafeDistance)}`);
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Handle collision response by recalculating path around obstacles
        function handleCollisionResponse(unit, blockedX, blockedY) {
            console.log(`🚫 ${unit.animal} collision detected - recalculating path around obstacle`);
            
            // Get current position and final destination
            const currentHex = screenToHex(unit.x, unit.y);
            let finalDestination;
            
            if (unit.path && unit.path.length > 0) {
                // Use the final destination from current path
                finalDestination = unit.path[unit.path.length - 1];
            } else if (unit.targetX !== null && unit.targetY !== null) {
                // Use the direct target
                finalDestination = screenToHex(unit.targetX, unit.targetY);
            } else {
                // No destination available - stop movement
                unit.isMoving = false;
                return false;
            }
            
            // Recalculate A* path from current position to final destination
            const newPath = findPathAStar(currentHex.x, currentHex.y, finalDestination.x, finalDestination.y, unit.animal);
            
            if (newPath && newPath.length > 1) {
                // Set new path, skipping current position
                unit.path = newPath.slice(1);
                unit.pathIndex = 0;
                unit.targetX = null;
                unit.targetY = null;
                console.log(`✅ ${unit.animal} found alternative path with ${newPath.length} steps`);
                return true;
            } else {
                // No alternative path found - stop movement
                console.log(`❌ ${unit.animal} no alternative path available - stopping`);
                unit.isMoving = false;
                unit.path = null;
                unit.pathIndex = 0;
                unit.targetX = null;
                unit.targetY = null;
                return false;
            }
        }
            
        // Get tile type at position (for gameplay logic)
        function getTileAt(x, y) {
            if (!gameMap || x < 0 || y < 0 || x >= gameMap.length || y >= gameMap[0].length) {
                return null;
            }
            return gameMap[x][y];
        }

        // Population management functions
        function initializePopulationTracking() {
            gameState.populationByTeam = { player: 0, enemy: 0 };
            gameState.populationByAnimal = {};
            
            // Initialize animal population counters
            Object.keys(animalConfigs).forEach(animal => {
                gameState.populationByAnimal[animal] = { player: 0, enemy: 0 };
            });
        }

        function updatePopulationCount(animal, team, delta) {
            gameState.populationByTeam[team] += delta;
            gameState.populationByAnimal[animal][team] += delta;
            gameState.population = gameState.populationByTeam.player + gameState.populationByTeam.enemy;
            
            console.log(`📊 Population update: ${animal} (${team}) ${delta > 0 ? '+' : ''}${delta}`);
            console.log(`📊 Current: ${team} total: ${gameState.populationByTeam[team]}, ${animal}: ${gameState.populationByAnimal[animal][team]}`);
        }

        function canSpawnUnit(animal, team) {
            // Check team population cap
            if (gameState.populationByTeam[team] >= gameState.maxPopulationPerTeam) {
                return false;
            }
            
            // Check animal type population cap
            if (gameState.populationByAnimal[animal][team] >= gameState.maxUnitsPerAnimalType) {
                return false;
            }
            
            return true;
        }

        function removeUnit(unit) {
            const index = gameState.units.indexOf(unit);
            if (index > -1) {
                gameState.units.splice(index, 1);
                updatePopulationCount(unit.animal, unit.team, -1);
                
                // Remove 3D model
                if (unit.modelElement && unit.modelElement.parentNode) {
                    unit.modelElement.parentNode.removeChild(unit.modelElement);
                }
                
                console.log(`💀 Removed ${unit.animal} (${unit.team}) - Population: ${gameState.populationByTeam[unit.team]}`);
            }
        }

        function getRandomHexTile() {
            // Weighted terrain generation - reduce Mountains/Hills by 25%
            const terrainWeights = [
                { tile: hexTileModels[0], weight: 0.1875 }, // Mountain: reduced from 0.25 to 0.1875 (-25%)
                { tile: hexTileModels[1], weight: 0.375 },  // Forest: 37.5%
                { tile: hexTileModels[2], weight: 0.1875 }, // Hill: reduced from 0.25 to 0.1875 (-25%)
                { tile: hexTileModels[3], weight: 0.25 }    // FarmLand: 25%
            ];
            
            const totalWeight = terrainWeights.reduce((sum, item) => sum + item.weight, 0);
            let random = Math.random() * totalWeight;
            
            for (const item of terrainWeights) {
                random -= item.weight;
                if (random <= 0) {
                    return item.tile;
                }
            }
            
            // Fallback to Forest if something goes wrong
            return hexTileModels[1];
        }

        // Generate a static map layout once
        function generateMapLayout(rows = 16, cols = 12) {
            if (gameMap) return gameMap; // Return cached map if exists
            
            gameMap = [];
            for (let i = 0; i < cols; i++) {
                gameMap[i] = [];
                for (let j = 0; j < rows; j++) {
                    const tileData = getRandomHexTile();
                    gameMap[i][j] = {
                        ...tileData,
                        x: i,
                        y: j,
                        // Keep terrain type for traversal logic, but render all as 3D models for visibility
                        terrainType: tileData.file.includes('Mountain') ? 'mountain' : 
                                   tileData.file.includes('Hill') ? 'hill' :
                                   tileData.file.includes('FarmLand') ? 'farmland' : 'forest',
                        isStatic: false // All tiles render as 3D models for visibility
                    };
                }
            }
            return gameMap;
        }

        function generateHexGrid(rows = 16, cols = 12) {
            const container = document.getElementById('hex-grid');
            if (!container) {
                console.warn('Hex grid container (#hex-grid) not found.');
                return;
            }

            // Clear any existing tiles
            container.innerHTML = '';

            // Generate or use cached map layout
            const mapLayout = generateMapLayout(rows, cols);
            
            // Count different terrain types for info
            let mountainCount = 0, hillCount = 0, farmlandCount = 0, forestCount = 0;
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    switch(mapLayout[i][j].terrainType) {
                        case 'mountain': mountainCount++; break;
                        case 'hill': hillCount++; break;
                        case 'farmland': farmlandCount++; break;
                        case 'forest': forestCount++; break;
                    }
                }
            }
            console.log(`Generated map terrain: ${mountainCount} Mountains, ${hillCount} Hills, ${farmlandCount} Farmland, ${forestCount} Forest`);
            console.log(`Traversability: Mountains/Hills block ground animals, all terrain allows flying animals (Owl/Bee)`);

            // Hex grid positioning with adjustable column/row gaps
            const hexWidth = devSettings.grid.tileWidth + devSettings.grid.columnGap;
            const hexHeight = devSettings.grid.tileHeight + devSettings.grid.rowGap;
            const hexOffset = devSettings.grid.hexOffset;

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const tileData = mapLayout[i][j];
                    
                    // Calculate position with adjustable gaps
                    let xPos, yPos;
                    if (i % 2 === 0) {
                        xPos = i * hexWidth;
                        yPos = j * hexHeight;
                    } else {
                        xPos = i * hexWidth;
                        yPos = j * hexHeight + hexOffset;
                    }

                    // All tiles are now 3D models for visibility
                    createTerrainTile(tileData, xPos, yPos, container);
                    }
            }
        }

        function createTerrainTile(tileData, xPos, yPos, container) {
            // Create a simplified 3D container for each tile
            const tileContainer = document.createElement('div');
            tileContainer.classList.add('tile-3d-container', tileData.terrainType);
            
            // Get terrain height for 3D effect
            const terrainHeight = getTerrainHeight(tileData.terrainType);
            
            // Position the 3D container
            tileContainer.style.position = 'absolute';
            tileContainer.style.left = xPos + 'px';
            tileContainer.style.top = yPos + 'px';
            tileContainer.style.width = devSettings.grid.tileWidth + 'px';
            tileContainer.style.height = devSettings.grid.tileHeight + 'px';
            tileContainer.style.transformStyle = 'preserve-3d';
            
            // Create single base terrain plane with visual depth
            const basePlane = document.createElement('div');
            basePlane.classList.add('terrain-plane', 'base-plane');
            basePlane.style.position = 'absolute';
            basePlane.style.width = '100%';
            basePlane.style.height = '100%';
            basePlane.style.background = getTerrainColor(tileData.terrainType);
            basePlane.style.transform = 'rotateX(90deg) translateZ(0px)';
            basePlane.style.border = '1px solid rgba(255,255,255,0.1)';
            
            // Add visual depth with box-shadow based on terrain height
            const shadowIntensity = Math.min(terrainHeight / 10, 8); // Max 8 layers of shadow
            basePlane.style.boxShadow = `0 0 ${shadowIntensity * 2}px rgba(0,0,0,0.3)`;
            
            // Create the model viewer positioned at terrain height
            const tile = document.createElement('model-viewer');
            tile.classList.add('hex-tile', tileData.terrainType);
            tile.setAttribute('src', tileData.file);
            tile.setAttribute('alt', tileData.alt);
            tile.setAttribute('interaction-prompt', 'none');
            tile.setAttribute('loading', 'lazy');
            tile.setAttribute('reveal', 'manual');
            
            // Use development settings for tile camera
            const orbit = `${devSettings.tileCamera.orbit}deg ${devSettings.tileCamera.elevation}deg ${devSettings.tileCamera.distance}m`;
            tile.setAttribute('camera-orbit', orbit);
            tile.setAttribute('field-of-view', '20deg');
            tile.setAttribute('rotation', '0deg 0deg 0deg');
            tile.setAttribute('disable-zoom', '');
            tile.setAttribute('disable-pan', '');
            tile.setAttribute('min-camera-orbit', orbit);
            tile.setAttribute('max-camera-orbit', orbit);
            
            // Position model viewer at terrain height
            tile.style.position = 'absolute';
            tile.style.width = '100%';
            tile.style.height = '100%';
            tile.style.transform = `translateZ(${terrainHeight}px)`;
            tile.style.transformStyle = 'preserve-3d';
            
            // Store tile coordinates for traversability checking  
            tile.dataset.hexX = Math.floor(xPos / (devSettings.grid.tileWidth + devSettings.grid.columnGap));
            tile.dataset.hexY = Math.floor(yPos / (devSettings.grid.tileHeight + devSettings.grid.rowGap));
            
            // Add traversability info for visual feedback
            if (tileData.terrainType === 'mountain' || tileData.terrainType === 'hill') {
                tile.title = `${tileData.terrainType} (Ground animals cannot pass, Flying animals can pass)`;
            } else {
                tile.title = `${tileData.terrainType} (All animals can pass)`;
            }
            
            tileContainer.appendChild(basePlane);
            tileContainer.appendChild(tile);
            container.appendChild(tileContainer);
            
            // Load model immediately
            tile.dismissPoster();
        }

        // Get terrain colors for 3D layers
        function getTerrainColor(terrainType) {
            const terrainColors = {
                'mountain': '#666666',  // Gray rock
                'hill': '#8B7355',      // Brown earth
                'forest': '#228B22',    // Green vegetation  
                'farmland': '#8B4513'   // Brown soil
            };
            return terrainColors[terrainType] || '#654321';
        }

        // Get height values for different terrain types to create 3D depth
        function getTerrainHeight(terrainType) {
            const terrainHeights = {
                'mountain': devSettings.terrain.mountainHeight,
                'hill': devSettings.terrain.hillHeight,
                'forest': devSettings.terrain.forestHeight,
                'farmland': devSettings.terrain.farmlandHeight
            };
            
            return (terrainHeights[terrainType] || 0) * devSettings.terrain.heightMultiplier;
        }

        // Performance: Progressive loading with Intersection Observer
        function setupProgressiveLoading() {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const tile = entry.target;
                        if (tile.hasAttribute('reveal')) {
                            tile.dismissPoster();
                            observer.unobserve(tile);
                        }
                    }
                });
            }, {
                rootMargin: '100px' // Load tiles 100px before they come into view
            });

            // Observe all hex tiles for progressive loading
            document.querySelectorAll('.tile-3d-container .hex-tile').forEach(tile => {
                if (tile.hasAttribute('reveal')) {
                    observer.observe(tile);
                        }
                    });
        }

        // Title Screen Logic
        document.addEventListener('DOMContentLoaded', function() {
            const animalCards = document.querySelectorAll('.animal-card');
            const startBtn = document.getElementById('startBtn');

            animalCards.forEach(card => {
                card.addEventListener('click', function() {
                    const animal = this.dataset.animal;
                    
                    if (this.classList.contains('selected')) {
                        this.classList.remove('selected');
                        gameState.selectedAnimals = gameState.selectedAnimals.filter(a => a !== animal);
                    } else if (gameState.selectedAnimals.length < 3) {
                        this.classList.add('selected');
                        gameState.selectedAnimals.push(animal);
                    }

                    // Update start button
                    if (gameState.selectedAnimals.length === 3) {
                        startBtn.classList.add('enabled');
                        startBtn.textContent = `Start with ${gameState.selectedAnimals.map(a => animalConfigs[a].emoji).join(' ')}`;
                    } else {
                        startBtn.classList.remove('enabled');
                        startBtn.textContent = `Select ${3 - gameState.selectedAnimals.length} more animals`;
                    }
                });
            });

            startBtn.addEventListener('click', function() {
                if (gameState.selectedAnimals.length === 3) {
                    startGame();
                }
            });
        });

        function startGame() {
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            document.getElementById('loadingIndicator').style.display = 'block';
            gameState.gameStarted = true;

            // Preload models then initialize game
            preloadModels().then(() => {
                document.getElementById('loadingIndicator').style.display = 'none';
                initializeGame();
                // No tree initialization needed
                gameLoop();
            });
        }

        async function preloadModels() {
            const modelsToLoad = gameState.selectedAnimals.map(animal => animalConfigs[animal].model);
            // No additional models to preload
            
            // Create invisible model-viewers to preload
            const preloadContainer = document.createElement('div');
            preloadContainer.style.position = 'absolute';
            preloadContainer.style.top = '-1000px';
            preloadContainer.style.left = '-1000px';
            document.body.appendChild(preloadContainer);

            const loadPromises = modelsToLoad.map(modelPath => {
                return new Promise((resolve, reject) => {
                    const modelViewer = document.createElement('model-viewer');
                    modelViewer.src = modelPath;
                    modelViewer.style.width = '1px';
                    modelViewer.style.height = '1px';
                    
                    modelViewer.addEventListener('load', () => {
                        resolve();
                    });
                    
                    modelViewer.addEventListener('error', () => {
                        console.warn(`Failed to load model: ${modelPath}`);
                        resolve(); // Continue even if model fails to load
                    });
                    
                    preloadContainer.appendChild(modelViewer);
                    
                    // Timeout fallback
                    setTimeout(() => resolve(), 3000);
                });
            });

            await Promise.all(loadPromises);
            document.body.removeChild(preloadContainer);
            gameState.modelsLoaded = true;
        }

        function initializeGame() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Initialize population tracking
            initializePopulationTracking();
            
            // Generate hex grid terrain
            generateHexGrid();
            
            // Setup progressive loading for better performance
            setTimeout(() => setupProgressiveLoading(), 100);

            // Create bases for selected animals
            gameState.selectedAnimals.forEach((animal, index) => {
                const base = {
                    animal: animal,
                    team: 'player',
                    x: 200 + (index * 150),
                    y: 200,
                    lastSpawn: 0,
                    spawnInterval: 15000, // 15 seconds
                    size: 40
                };
                gameState.bases.push(base);
            });

            // Create enemy bases with 3 random remaining animals
            const remainingAnimals = Object.keys(animalConfigs).filter(a => !gameState.selectedAnimals.includes(a));
            // Shuffle simple
            for (let i = remainingAnimals.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [remainingAnimals[i], remainingAnimals[j]] = [remainingAnimals[j], remainingAnimals[i]];
            }
            const enemyAnimals = remainingAnimals.slice(0, 3);

            enemyAnimals.forEach((animal, index) => {
                const base = {
                    animal: animal,
                    team: 'enemy',
                    x: gameState.mapSize.width - (200 + (index * 150)),
                    y: gameState.mapSize.height - 200,
                    lastSpawn: 0,
                    spawnInterval: 15000,
                    size: 40
                };
                gameState.bases.push(base);
            });

            // Create control buttons
            createControlButtons();

            // Add event listeners
            setupEventListeners();
            
            // Initialize development panel
            initDevPanel();
            
            // Apply initial camera settings
            updateGlobalCameraPosition();
        }

        function createControlButtons() {
            const controlPanel = document.getElementById('controlPanel');
            controlPanel.innerHTML = '';

            gameState.selectedAnimals.forEach(animal => {
                const btn = document.createElement('button');
                btn.className = 'animal-btn';
                btn.textContent = `Select All ${animalConfigs[animal].emoji}`;
                btn.dataset.animal = animal;
                btn.addEventListener('click', () => selectAllUnitsOfType(animal));
                controlPanel.appendChild(btn);
            });
        }

        function setupEventListeners() {
            const canvas = document.getElementById('gameCanvas');

            // Mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);

            // Window resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                updateUnitModelPositions();
            });
        }

        function handleMouseDown(e) {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left + gameState.camera.x;
            const y = e.clientY - rect.top + gameState.camera.y;

            if (e.button === 0) { // Left click
                startSelection(x, y);
            } else if (e.button === 2) { // Right click
                moveSelectedUnits(x, y);
            }
        }

        function handleMouseMove(e) {
            if (gameState.isSelecting) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left + gameState.camera.x;
                const y = e.clientY - rect.top + gameState.camera.y;
                updateSelection(x, y);
            }
        }

        function handleMouseUp(e) {
            if (gameState.isSelecting) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left + gameState.camera.x;
                const y = e.clientY - rect.top + gameState.camera.y;
                finishSelection(x, y);
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = e.target.getBoundingClientRect();
            const x = touch.clientX - rect.left + gameState.camera.x;
            const y = touch.clientY - rect.top + gameState.camera.y;
            
            startSelection(x, y);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (gameState.isSelecting && e.touches.length === 1) {
                const touch = e.touches[0];
                const rect = e.target.getBoundingClientRect();
                const x = touch.clientX - rect.left + gameState.camera.x;
                const y = touch.clientY - rect.top + gameState.camera.y;
                updateSelection(x, y);
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (gameState.isSelecting) {
                if (e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    const rect = e.target.getBoundingClientRect();
                    const x = touch.clientX - rect.left + gameState.camera.x;
                    const y = touch.clientY - rect.top + gameState.camera.y;
                    finishSelection(x, y);
                }
            }
        }

        function startSelection(x, y) {
            // Check if clicking on a unit first
            const clickedUnit = gameState.units.find(unit => {
                const dx = unit.x - x;
                const dy = unit.y - y;
                return Math.sqrt(dx * dx + dy * dy) < unit.size;
            });

            if (clickedUnit) {
                // Single unit selection
                gameState.selectedUnits = [clickedUnit];
                updateSelectedCount();
                updateUnitSelectionVisuals();
            } else {
                // Start box selection
                gameState.isSelecting = true;
                gameState.selectionStart = { x, y };
                gameState.selectedUnits = [];
                updateSelectedCount();
                updateUnitSelectionVisuals();
            }
        }

        function updateSelection(x, y) {
            const selectionBox = document.getElementById('selectionBox');
            const canvas = document.getElementById('gameCanvas');
            
            const startX = Math.min(gameState.selectionStart.x - gameState.camera.x, x - gameState.camera.x);
            const startY = Math.min(gameState.selectionStart.y - gameState.camera.y, y - gameState.camera.y);
            const width = Math.abs(x - gameState.selectionStart.x);
            const height = Math.abs(y - gameState.selectionStart.y);

            selectionBox.style.left = startX + 'px';
            selectionBox.style.top = startY + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
            selectionBox.style.display = 'block';
        }

        function finishSelection(x, y) {
            gameState.isSelecting = false;
            document.getElementById('selectionBox').style.display = 'none';

            // Find units within selection box
            const minX = Math.min(gameState.selectionStart.x, x);
            const maxX = Math.max(gameState.selectionStart.x, x);
            const minY = Math.min(gameState.selectionStart.y, y);
            const maxY = Math.max(gameState.selectionStart.y, y);

            gameState.selectedUnits = gameState.units.filter(unit => 
                unit.team === 'player' &&
                unit.x >= minX && unit.x <= maxX && 
                unit.y >= minY && unit.y <= maxY
            );

            updateSelectedCount();
            updateUnitSelectionVisuals();
        }

        function moveSelectedUnits(x, y) {
            if (gameState.selectedUnits.length > 0) {
                console.log(`🎯 Moving ${gameState.selectedUnits.length} units to (${Math.round(x)}, ${Math.round(y)})`);
                
                // Create formation around target point
                const formationRadius = Math.sqrt(gameState.selectedUnits.length) * 20;
                
                gameState.selectedUnits.forEach((unit, index) => {
                    const angle = (index / gameState.selectedUnits.length) * Math.PI * 2;
                    const offsetX = Math.cos(angle) * formationRadius;
                    const offsetY = Math.sin(angle) * formationRadius;
                    
                    const targetX = x + offsetX;
                    const targetY = y + offsetY;
                    
                    console.log(`📍 Setting path for ${unit.animal} from (${Math.round(unit.x)}, ${Math.round(unit.y)}) to (${Math.round(targetX)}, ${Math.round(targetY)})`);
                    
                    // Use A* pathfinding for optimal route finding
                    setUnitPath(unit, targetX, targetY);
                });
            }
        }

        // Find the nearest traversable tile for an animal
        function findNearestTraversableTile(startX, startY, animalType) {
            const maxSearchRadius = 5; // Limit search to prevent performance issues
            
            for (let radius = 1; radius <= maxSearchRadius; radius++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        const checkX = startX + dx;
                        const checkY = startY + dy;
                        
                        if (isTileTraversable(checkX, checkY, animalType)) {
                            return { x: checkX, y: checkY };
                        }
                    }
                }
            }
            return null; // No traversable tile found within search radius
        }

        // A* Pathfinding Implementation
        class AStarNode {
            constructor(x, y, gCost = 0, hCost = 0, parent = null) {
                this.x = x;
                this.y = y;
                this.gCost = gCost; // Distance from start
                this.hCost = hCost; // Heuristic distance to goal
                this.fCost = gCost + hCost; // Total cost
                this.parent = parent;
            }
            
            equals(other) {
                return this.x === other.x && this.y === other.y;
            }
        }

        function findPathAStar(startX, startY, goalX, goalY, animalType) {
            const openSet = [];
            const closedSet = [];
            const startNode = new AStarNode(startX, startY, 0, heuristic(startX, startY, goalX, goalY));
            
            openSet.push(startNode);
            
            while (openSet.length > 0) {
                // Find node with lowest fCost
                let currentNode = openSet[0];
                let currentIndex = 0;
                
                for (let i = 1; i < openSet.length; i++) {
                    if (openSet[i].fCost < currentNode.fCost || 
                        (openSet[i].fCost === currentNode.fCost && openSet[i].hCost < currentNode.hCost)) {
                        currentNode = openSet[i];
                        currentIndex = i;
                    }
                }
                
                // Move current from open to closed
                openSet.splice(currentIndex, 1);
                closedSet.push(currentNode);
                
                // Check if we reached the goal
                if (currentNode.x === goalX && currentNode.y === goalY) {
                    return reconstructPath(currentNode);
                }
                
                // Check all neighbors
                const neighbors = getNeighbors(currentNode.x, currentNode.y);
                for (const neighbor of neighbors) {
                    const [nx, ny] = neighbor;
                    
                    // Skip if not traversable or already in closed set
                    if (!isTileTraversable(nx, ny, animalType) || 
                        closedSet.some(node => node.x === nx && node.y === ny)) {
                        continue;
                    }
                    
                    const gCost = currentNode.gCost + getMovementCost(currentNode.x, currentNode.y, nx, ny, animalType);
                    const hCost = heuristic(nx, ny, goalX, goalY);
                    const neighborNode = new AStarNode(nx, ny, gCost, hCost, currentNode);
                    
                    // Check if this path to neighbor is better
                    const existingIndex = openSet.findIndex(node => node.x === nx && node.y === ny);
                    if (existingIndex === -1) {
                        openSet.push(neighborNode);
                    } else if (gCost < openSet[existingIndex].gCost) {
                        openSet[existingIndex] = neighborNode;
                    }
                }
            }
            
            return null; // No path found
        }

        function heuristic(x1, y1, x2, y2) {
            // Improved hex grid distance calculation
            const dx = x2 - x1;
            const dy = y2 - y1;
            
            // For hex grids, we need to account for the offset pattern
            let distance;
            if (Math.sign(dx) === Math.sign(dy)) {
                distance = Math.abs(dx + dy);
            } else {
                distance = Math.max(Math.abs(dx), Math.abs(dy));
            }
            
            return distance;
        }

        function getMovementCost(x1, y1, x2, y2, animalType) {
            // Base movement cost
            let cost = 1;
            
            // Diagonal movement costs slightly more (for hex grids this is minimal)
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            if (dx > 0 && dy > 0) {
                cost *= 1.1; // Slight diagonal penalty
            }
            
            // Check destination tile for terrain-specific costs
            const tile = getTileAt(x2, y2);
            if (tile) {
                // Add terrain preferences to encourage optimal routing
                if (tile.terrainType === 'forest') {
                    cost *= 1.2; // Forest is slightly harder to traverse
                } else if (tile.terrainType === 'farmland') {
                    cost *= 0.9; // Farmland is easier to traverse
                }
            }
            
            return cost;
        }

        function getNeighbors(x, y) {
            // Hex grid neighbors (6 directions)
            if (x % 2 === 0) { // Even column
                return [
                    [x, y-1],     // North
                    [x+1, y-1],   // Northeast
                    [x+1, y],     // Southeast
                    [x, y+1],     // South
                    [x-1, y],     // Southwest
                    [x-1, y-1]    // Northwest
                ];
            } else { // Odd column
                return [
                    [x, y-1],     // North
                    [x+1, y],     // Northeast
                    [x+1, y+1],   // Southeast
                    [x, y+1],     // South
                    [x-1, y+1],   // Southwest
                    [x-1, y]      // Northwest
                ];
            }
        }

        function reconstructPath(goalNode) {
            const path = [];
            let current = goalNode;
            
            while (current) {
                path.unshift({ x: current.x, y: current.y });
                current = current.parent;
            }
            
            return path;
        }

        // Enhanced unit movement with A* pathfinding
        function setUnitPath(unit, targetX, targetY) {
            // Convert screen coordinates to hex coordinates using helper functions
            const startHex = screenToHex(unit.x, unit.y);
            const goalHex = screenToHex(targetX, targetY);
            
            console.log(`🗺️ Finding path for ${unit.animal} from hex (${startHex.x}, ${startHex.y}) to hex (${goalHex.x}, ${goalHex.y})`);
            console.log(`📍 Start traversable: ${isTileTraversable(startHex.x, startHex.y, unit.animal)}, Goal traversable: ${isTileTraversable(goalHex.x, goalHex.y, unit.animal)}`);
            
            // Find path using A*
            const path = findPathAStar(startHex.x, startHex.y, goalHex.x, goalHex.y, unit.animal);
            
            if (path && path.length > 1) {
                unit.path = path.slice(1); // Remove starting position
                unit.pathIndex = 0;
                unit.isMoving = true;
                unit.targetX = null;
                unit.targetY = null;
                console.log(`✅ ${unit.animal} found A* path with ${path.length} steps`);
            } else {
                // Fallback to direct movement
                unit.targetX = targetX;
                unit.targetY = targetY;
                unit.isMoving = true;
                unit.path = null;
                unit.pathIndex = 0;
                console.log(`⚠️ ${unit.animal} using direct movement (no A* path found) - isMoving: ${unit.isMoving}`);
            }
        }

        // Try to find an alternative movement direction when blocked (legacy fallback)
        function findAlternativeMove(unit, originalMoveX, originalMoveY) {
            // Try several alternative directions around the obstacle
            const alternatives = [
                { x: originalMoveX * 0.7, y: originalMoveY * 0.7 + unit.speed * 0.5 }, // Slight right
                { x: originalMoveX * 0.7, y: originalMoveY * 0.7 - unit.speed * 0.5 }, // Slight left
                { x: originalMoveX * 0.5, y: originalMoveY * 0.9 }, // More vertical
                { x: originalMoveX * 0.9, y: originalMoveY * 0.5 }, // More horizontal
                { x: -originalMoveY * 0.3, y: originalMoveX * 0.3 }, // Perpendicular right
                { x: originalMoveY * 0.3, y: -originalMoveX * 0.3 }  // Perpendicular left
            ];
            
            for (const alt of alternatives) {
                const testX = unit.x + alt.x;
                const testY = unit.y + alt.y;
                
                // Use proper collision detection with unit size
                if (!checkHexCollision(testX, testY, unit.animal, unit.size)) {
                    return alt;
                }
            }
            
            return null; // No alternative movement found
        }

        function selectAllUnitsOfType(animalType) {
            gameState.selectedUnits = gameState.units.filter(unit => unit.animal === animalType && unit.team === 'player');
            updateSelectedCount();
            updateUnitSelectionVisuals();

            // Visual feedback
            const buttons = document.querySelectorAll('.animal-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-animal="${animalType}"]`).classList.add('active');
        }

        function createUnitModel(unit) {
            const modelContainer = document.createElement('div');
            modelContainer.className = 'unit-model';
            modelContainer.id = `unit-${unit.id}`;
            
            const modelViewer = document.createElement('model-viewer');
            modelViewer.src = animalConfigs[unit.animal].model;
            modelViewer.alt = `${unit.animal} unit`;
            modelViewer.autoRotate = false;
            modelViewer.cameraControls = false;
            modelViewer.disableZoom = true;
            modelViewer.rotationPerSecond = '0deg';
            modelViewer.style.width = (unit.size * 3) + 'px';
            modelViewer.style.height = (unit.size * 3) + 'px';
            
            // Fix camera and framing to prevent clipping
            modelViewer.cameraOrbit = '0deg 90deg 50m';
            modelViewer.fieldOfView = '10deg';
            modelViewer.minCameraOrbit = 'auto auto auto';
            modelViewer.maxCameraOrbit = 'auto auto auto';
            modelViewer.setAttribute('camera-target', 'auto auto auto');
            modelViewer.setAttribute('max-field-of-view', '45deg');
            modelViewer.setAttribute('min-field-of-view', '5deg');
            
            // Core model-viewer settings to prevent internal clipping
            modelViewer.setAttribute('auto-rotate-delay', '0');
            modelViewer.setAttribute('interaction-prompt', 'none');
            modelViewer.setAttribute('loading', 'eager');
            modelViewer.setAttribute('reveal', 'auto');
            
            // Wait for model to load then adjust framing
            modelViewer.addEventListener('load', () => {
                // Get the model's actual bounds and adjust camera accordingly
                setTimeout(() => {
                    try {
                        const center = modelViewer.getCameraTarget();
                        const bounds = modelViewer.getBoundingBoxCenter();
                        // Set camera far enough to see entire model
                        modelViewer.cameraOrbit = '0deg 75deg 100m';
                        modelViewer.fieldOfView = '15deg';
                    } catch (e) {
                        // Fallback if bounds calculation fails
                        modelViewer.cameraOrbit = '0deg 75deg 80m';
                        modelViewer.fieldOfView = '20deg';
                    }
                }, 100);
            });
            
            modelContainer.appendChild(modelViewer);
            document.getElementById('modelsContainer').appendChild(modelContainer);
            
            return modelContainer;
        }

        function spawnUnit(base) {
            // Check if we can spawn this unit (population caps)
            if (!canSpawnUnit(base.animal, base.team)) {
                console.log(`🚫 Cannot spawn ${base.animal} (${base.team}) - population cap reached`);
                return null;
            }
            
            const angle = Math.random() * Math.PI * 2;
            const distance = base.size + 30;
            
            const unit = {
                animal: base.animal,
                team: base.team,
                x: base.x + Math.cos(angle) * distance,
                y: base.y + Math.sin(angle) * distance,
                targetX: null,
                targetY: null,
                isMoving: false,
                size: animalConfigs[base.animal].size,
                speed: animalConfigs[base.animal].speed,
                id: Date.now() + Math.random(),
                modelElement: null,
                // A* pathfinding properties
                path: null,
                pathIndex: 0
            };

            // Create 3D model for the unit
            unit.modelElement = createUnitModel(unit);
            
            gameState.units.push(unit);
            updatePopulationCount(base.animal, base.team, 1);
            
            console.log(`🐾 Spawned ${unit.animal} (${unit.team}) at (${Math.round(unit.x)}, ${Math.round(unit.y)}) - Total: ${gameState.populationByTeam[base.team]}`);
            
            return unit;
        }

        function updateUnits(deltaTime) {
            gameState.units.forEach(unit => {
                                if (unit.isMoving) {
                    // A* path-based movement
                    if (unit.path && unit.pathIndex < unit.path.length) {
                        const currentTarget = unit.path[unit.pathIndex];
                        const targetPos = hexToScreen(currentTarget.x, currentTarget.y);
                        
                        const dx = targetPos.x - unit.x;
                        const dy = targetPos.y - unit.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 10) { // Increased threshold for more precise movement
                            const moveX = (dx / distance) * unit.speed * devSettings.units.speedMultiplier;
                            const moveY = (dy / distance) * unit.speed * devSettings.units.speedMultiplier;
                            
                            // Calculate next position
                            const nextX = unit.x + moveX;
                            const nextY = unit.y + moveY;
                            
                            // Check for collision using actual unit size
                            if (!checkHexCollision(nextX, nextY, unit.animal, unit.size)) {
                                // Move to the next position
                                unit.x = nextX;
                                unit.y = nextY;
                                
                                // Rotate model to face movement direction
                                if (unit.modelElement) {
                                    const angleRad = Math.atan2(dy, dx);
                                    const angleDeg = (angleRad * 180 / Math.PI);
                                    const modelViewer = unit.modelElement.querySelector('model-viewer');
                                    if (modelViewer) {
                                        const yaw = -(angleDeg - 90);
                                        modelViewer.setAttribute('rotation', `0deg ${yaw.toFixed(2)}deg 0deg`);
                                    }
                                }
                            } else {
                                // Collision detected - recalculate path around obstacle
                                handleCollisionResponse(unit, nextX, nextY);
                            }
                        } else {
                            // Reached current waypoint, move to next
                            unit.pathIndex++;
                            if (unit.pathIndex >= unit.path.length) {
                                // Reached final destination
                                unit.isMoving = false;
                                unit.path = null;
                                unit.pathIndex = 0;
                            }
                        }
                    }
                                        // Legacy direct movement (fallback)
                    else if (unit.targetX !== null && unit.targetY !== null) {
                        const dx = unit.targetX - unit.x;
                        const dy = unit.targetY - unit.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 10) { // Increased threshold for consistency
                            const moveX = (dx / distance) * unit.speed * devSettings.units.speedMultiplier;
                            const moveY = (dy / distance) * unit.speed * devSettings.units.speedMultiplier;
                            
                            // Calculate next position
                            const nextX = unit.x + moveX;
                            const nextY = unit.y + moveY;
                            
                            // Check for collision using actual unit size
                            if (!checkHexCollision(nextX, nextY, unit.animal, unit.size)) {
                                // Move to the next position
                                unit.x = nextX;
                                unit.y = nextY;
                                
                                // Rotate model to face movement direction
                                if (unit.modelElement) {
                                    const angleRad = Math.atan2(dy, dx);
                                    const angleDeg = (angleRad * 180 / Math.PI);
                                    const modelViewer = unit.modelElement.querySelector('model-viewer');
                                    if (modelViewer) {
                                        const yaw = -(angleDeg - 90);
                                        modelViewer.setAttribute('rotation', `0deg ${yaw.toFixed(2)}deg 0deg`);
                                    }
                                }
                            } else {
                                // Collision detected - recalculate path around obstacle
                                handleCollisionResponse(unit, nextX, nextY);
                            }
                        } else {
                            unit.isMoving = false;
                            unit.targetX = null;
                            unit.targetY = null;
                        }
                    }
                }

                if (unit.team === 'enemy' && !unit.isMoving) {
                    // Simple AI: move toward nearest player base
                    const playerBases = gameState.bases.filter(b => b.team === 'player');
                    if (playerBases.length > 0) {
                        let nearest = playerBases[0];
                        let nearestDist = Math.hypot(nearest.x - unit.x, nearest.y - unit.y);
                        playerBases.forEach(b => {
                            const d = Math.hypot(b.x - unit.x, b.y - unit.y);
                            if (d < nearestDist) {
                                nearest = b;
                                nearestDist = d;
                            }
                        });
                        unit.targetX = nearest.x;
                        unit.targetY = nearest.y;
                        unit.isMoving = true;
                    }
                }
            });
            
            updateUnitModelPositions();
        }

        function updateUnitModelPositions() {
            gameState.units.forEach(unit => {
                if (unit.modelElement) {
                    const modelSize = unit.size * 3; // Keep consistent with creation size
                    const screenX = unit.x - gameState.camera.x - modelSize/2;
                    const screenY = unit.y - gameState.camera.y - modelSize/2;
                    
                    unit.modelElement.style.left = screenX + 'px';
                    unit.modelElement.style.top = screenY + 'px';
                    // Don't resize - maintain original size to prevent clipping
                    // unit.modelElement.style.width = modelSize + 'px';
                    // unit.modelElement.style.height = modelSize + 'px';
                }
            });
            
            // No tree position updates needed
        }

        function updateUnitSelectionVisuals() {
            gameState.units.forEach(unit => {
                if (unit.modelElement) {
                    if (gameState.selectedUnits.includes(unit)) {
                        unit.modelElement.classList.add('selected');
                    } else {
                        unit.modelElement.classList.remove('selected');
                    }
                }
            });
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = gameState.selectedUnits.length;
            document.getElementById('population').textContent = gameState.population;
        }

        // Intelligent spawn manager to maintain population caps
        function managePopulation() {
            gameState.bases.forEach(base => {
                // Check if this animal type needs replenishment
                const currentCount = gameState.populationByAnimal[base.animal][base.team];
                const teamTotal = gameState.populationByTeam[base.team];
                
                // Only spawn if:
                // 1. Animal type is below cap (33)
                // 2. Team total is below cap (99)
                // 3. Enough time has passed since last spawn
                if (currentCount < gameState.maxUnitsPerAnimalType && 
                    teamTotal < gameState.maxPopulationPerTeam &&
                    Date.now() - base.lastSpawn > base.spawnInterval) {
                    
                    const spawned = spawnUnit(base);
                    if (spawned) {
                        base.lastSpawn = Date.now();
                        console.log(`🏭 Base spawned ${base.animal} for ${base.team} - ${currentCount + 1}/${gameState.maxUnitsPerAnimalType}`);
                    }
                }
            });
        }

        // ===== DEVELOPMENT PANEL FUNCTIONS =====
        
        function initDevPanel() {
            // Toggle button functionality
            document.getElementById('devToggle').addEventListener('click', () => {
                const panel = document.getElementById('devPanel');
                panel.classList.toggle('collapsed');
            });

            // Setup all control listeners
            setupCameraControls();
            setupGridControls();
            setupTerrainControls();
            setupUnitControls();
            setupPopulationControls();
            setupDebugControls();
        }

        function setupCameraControls() {
            const globalCameraX = document.getElementById('globalCameraX');
            const globalCameraY = document.getElementById('globalCameraY');
            const globalCameraZoom = document.getElementById('globalCameraZoom');
            const globalCameraRotation = document.getElementById('globalCameraRotation');
            const globalCameraPitch = document.getElementById('globalCameraPitch');
            const globalCameraYaw = document.getElementById('globalCameraYaw');
            const globalCameraRoll = document.getElementById('globalCameraRoll');
            const tileCameraOrbit = document.getElementById('tileCameraOrbit');
            const tileCameraElevation = document.getElementById('tileCameraElevation');
            const tileCameraDistance = document.getElementById('tileCameraDistance');

            globalCameraX.addEventListener('input', (e) => {
                devSettings.globalCamera.x = parseInt(e.target.value);
                gameState.camera.x = devSettings.globalCamera.x;
                document.getElementById('globalCameraXValue').textContent = e.target.value;
                updateGlobalCameraPosition();
            });

            globalCameraY.addEventListener('input', (e) => {
                devSettings.globalCamera.y = parseInt(e.target.value);
                gameState.camera.y = devSettings.globalCamera.y;
                document.getElementById('globalCameraYValue').textContent = e.target.value;
                updateGlobalCameraPosition();
            });

            globalCameraZoom.addEventListener('input', (e) => {
                devSettings.globalCamera.zoom = parseFloat(e.target.value);
                document.getElementById('globalCameraZoomValue').textContent = e.target.value + 'x';
                updateGlobalCameraPosition();
            });

            globalCameraRotation.addEventListener('input', (e) => {
                devSettings.globalCamera.rotation = parseInt(e.target.value);
                document.getElementById('globalCameraRotationValue').textContent = e.target.value + '°';
                updateGlobalCameraPosition();
            });

            globalCameraPitch.addEventListener('input', (e) => {
                devSettings.globalCamera.pitch = parseInt(e.target.value);
                document.getElementById('globalCameraPitchValue').textContent = e.target.value + '°';
                updateGlobalCameraPosition();
            });

            globalCameraYaw.addEventListener('input', (e) => {
                devSettings.globalCamera.yaw = parseInt(e.target.value);
                document.getElementById('globalCameraYawValue').textContent = e.target.value + '°';
                updateGlobalCameraPosition();
            });

            globalCameraRoll.addEventListener('input', (e) => {
                devSettings.globalCamera.roll = parseInt(e.target.value);
                document.getElementById('globalCameraRollValue').textContent = e.target.value + '°';
                updateGlobalCameraPosition();
            });

            tileCameraOrbit.addEventListener('input', (e) => {
                devSettings.tileCamera.orbit = parseInt(e.target.value);
                updateAllTileCameras();
                document.getElementById('tileCameraOrbitValue').textContent = e.target.value + '°';
            });

            tileCameraElevation.addEventListener('input', (e) => {
                devSettings.tileCamera.elevation = parseInt(e.target.value);
                updateAllTileCameras();
                document.getElementById('tileCameraElevationValue').textContent = e.target.value + '°';
            });

            tileCameraDistance.addEventListener('input', (e) => {
                devSettings.tileCamera.distance = parseInt(e.target.value);
                updateAllTileCameras();
                document.getElementById('tileCameraDistanceValue').textContent = e.target.value + 'm';
            });
        }

        function setupTerrainControls() {
            const mountainHeight = document.getElementById('mountainHeight');
            const hillHeight = document.getElementById('hillHeight');
            const forestHeight = document.getElementById('forestHeight');
            const farmlandHeight = document.getElementById('farmlandHeight');
            const heightMultiplier = document.getElementById('heightMultiplier');

            mountainHeight.addEventListener('input', (e) => {
                devSettings.terrain.mountainHeight = parseInt(e.target.value);
                document.getElementById('mountainHeightValue').textContent = e.target.value + 'px';
                regenerateGrid();
            });

            hillHeight.addEventListener('input', (e) => {
                devSettings.terrain.hillHeight = parseInt(e.target.value);
                document.getElementById('hillHeightValue').textContent = e.target.value + 'px';
                regenerateGrid();
            });

            forestHeight.addEventListener('input', (e) => {
                devSettings.terrain.forestHeight = parseInt(e.target.value);
                document.getElementById('forestHeightValue').textContent = e.target.value + 'px';
                regenerateGrid();
            });

            farmlandHeight.addEventListener('input', (e) => {
                devSettings.terrain.farmlandHeight = parseInt(e.target.value);
                document.getElementById('farmlandHeightValue').textContent = e.target.value + 'px';
                regenerateGrid();
            });

            heightMultiplier.addEventListener('input', (e) => {
                devSettings.terrain.heightMultiplier = parseFloat(e.target.value);
                document.getElementById('heightMultiplierValue').textContent = e.target.value + 'x';
                regenerateGrid();
            });
        }

        function setupGridControls() {
            const gridCols = document.getElementById('gridCols');
            const gridRows = document.getElementById('gridRows');
            const tileWidth = document.getElementById('tileWidth');
            const tileHeight = document.getElementById('tileHeight');
            const hexOffset = document.getElementById('hexOffset');
            const columnGap = document.getElementById('columnGap');
            const rowGap = document.getElementById('rowGap');

            gridCols.addEventListener('input', (e) => {
                devSettings.grid.cols = parseInt(e.target.value);
                document.getElementById('gridColsValue').textContent = e.target.value;
                regenerateGrid();
            });

            gridRows.addEventListener('input', (e) => {
                devSettings.grid.rows = parseInt(e.target.value);
                document.getElementById('gridRowsValue').textContent = e.target.value;
                regenerateGrid();
            });

            tileWidth.addEventListener('input', (e) => {
                devSettings.grid.tileWidth = parseInt(e.target.value);
                document.getElementById('tileWidthValue').textContent = e.target.value + 'px';
                // Update hex offset when tile width changes
                devSettings.grid.hexOffset = devSettings.grid.tileHeight / 2;
                regenerateGrid();
            });

            tileHeight.addEventListener('input', (e) => {
                devSettings.grid.tileHeight = parseInt(e.target.value);
                document.getElementById('tileHeightValue').textContent = e.target.value + 'px';
                // Update hex offset when tile height changes  
                devSettings.grid.hexOffset = devSettings.grid.tileHeight / 2;
                regenerateGrid();
            });

            hexOffset.addEventListener('input', (e) => {
                devSettings.grid.hexOffset = parseInt(e.target.value);
                document.getElementById('hexOffsetValue').textContent = e.target.value + 'px';
                regenerateGrid();
            });

            columnGap.addEventListener('input', (e) => {
                devSettings.grid.columnGap = parseInt(e.target.value);
                document.getElementById('columnGapValue').textContent = e.target.value + 'px';
                regenerateGrid();
            });

            rowGap.addEventListener('input', (e) => {
                devSettings.grid.rowGap = parseInt(e.target.value);
                document.getElementById('rowGapValue').textContent = e.target.value + 'px';
                regenerateGrid();
            });
        }

        function setupUnitControls() {
            const unitSpeedMultiplier = document.getElementById('unitSpeedMultiplier');
            const unitSizeMultiplier = document.getElementById('unitSizeMultiplier');
            const spawnInterval = document.getElementById('spawnInterval');

            unitSpeedMultiplier.addEventListener('input', (e) => {
                devSettings.units.speedMultiplier = parseFloat(e.target.value);
                document.getElementById('unitSpeedMultiplierValue').textContent = e.target.value + 'x';
            });

            unitSizeMultiplier.addEventListener('input', (e) => {
                devSettings.units.sizeMultiplier = parseFloat(e.target.value);
                document.getElementById('unitSizeMultiplierValue').textContent = e.target.value + 'x';
                updateAllUnitSizes();
            });

            spawnInterval.addEventListener('input', (e) => {
                devSettings.units.spawnInterval = parseInt(e.target.value);
                gameState.bases.forEach(base => base.spawnInterval = devSettings.units.spawnInterval * 1000);
                document.getElementById('spawnIntervalValue').textContent = e.target.value + 's';
            });
        }

        function setupPopulationControls() {
            const maxPerTeam = document.getElementById('maxPerTeam');
            const maxPerAnimal = document.getElementById('maxPerAnimal');
            const enableDeathSim = document.getElementById('enableDeathSim');

            maxPerTeam.addEventListener('input', (e) => {
                devSettings.population.maxPerTeam = parseInt(e.target.value);
                gameState.maxPopulationPerTeam = devSettings.population.maxPerTeam;
                document.getElementById('maxPerTeamValue').textContent = e.target.value;
            });

            maxPerAnimal.addEventListener('input', (e) => {
                devSettings.population.maxPerAnimal = parseInt(e.target.value);
                gameState.maxUnitsPerAnimalType = devSettings.population.maxPerAnimal;
                document.getElementById('maxPerAnimalValue').textContent = e.target.value;
            });

            enableDeathSim.addEventListener('change', (e) => {
                devSettings.population.enableDeathSim = e.target.checked;
            });
        }

        function setupDebugControls() {
            const showCollisionDebug = document.getElementById('showCollisionDebug');
            const showPathDebug = document.getElementById('showPathDebug');
            const showGridDebug = document.getElementById('showGridDebug');

            showCollisionDebug.addEventListener('change', (e) => {
                devSettings.debug.showCollision = e.target.checked;
            });

            showPathDebug.addEventListener('change', (e) => {
                devSettings.debug.showPath = e.target.checked;
            });

            showGridDebug.addEventListener('change', (e) => {
                devSettings.debug.showGrid = e.target.checked;
            });
        }

        // Development helper functions
        function updateAllTileCameras() {
            console.log(`🎥 Updating tile cameras: ${devSettings.tileCamera.orbit}° ${devSettings.tileCamera.elevation}° ${devSettings.tileCamera.distance}m`);
            document.querySelectorAll('#hex-grid .tile-3d-container model-viewer').forEach(modelViewer => {
                const orbit = `${devSettings.tileCamera.orbit}deg ${devSettings.tileCamera.elevation}deg ${devSettings.tileCamera.distance}m`;
                modelViewer.setAttribute('camera-orbit', orbit);
                modelViewer.setAttribute('min-camera-orbit', orbit);
                modelViewer.setAttribute('max-camera-orbit', orbit);
                
                // Force camera update
                if (modelViewer.resetTurntableRotation) {
                    modelViewer.resetTurntableRotation();
                }
            });
        }

        function updateGlobalCameraPosition() {
            console.log(`🌍 Updating global camera: (${gameState.camera.x}, ${gameState.camera.y}) zoom: ${devSettings.globalCamera.zoom} rotation: ${devSettings.globalCamera.rotation}° pitch: ${devSettings.globalCamera.pitch}° yaw: ${devSettings.globalCamera.yaw}° roll: ${devSettings.globalCamera.roll}°`);
            
            // Build comprehensive 3D transform with all camera controls
            const transform = `
                translate(${-gameState.camera.x}px, ${-gameState.camera.y}px) 
                scale(${devSettings.globalCamera.zoom}) 
                rotate(${devSettings.globalCamera.rotation}deg)
                rotateX(${devSettings.globalCamera.pitch}deg)
                rotateY(${devSettings.globalCamera.yaw}deg)
                rotateZ(${devSettings.globalCamera.roll}deg)
            `;
            
            // Update hex grid container with full 3D transformation
            const hexGrid = document.getElementById('hex-grid');
            if (hexGrid) {
                hexGrid.style.transform = transform;
                hexGrid.style.transformStyle = 'preserve-3d';
                hexGrid.style.perspective = '1000px';
            }
            
            // Update game screen with full 3D transformation
            const gameScreen = document.getElementById('gameScreen');
            if (gameScreen) {
                gameScreen.style.transform = `
                    scale(${devSettings.globalCamera.zoom}) 
                    rotate(${devSettings.globalCamera.rotation}deg)
                    rotateX(${devSettings.globalCamera.pitch}deg)
                    rotateY(${devSettings.globalCamera.yaw}deg)
                    rotateZ(${devSettings.globalCamera.roll}deg)
                `;
                gameScreen.style.transformOrigin = 'center center';
                gameScreen.style.transformStyle = 'preserve-3d';
                gameScreen.style.perspective = '1000px';
            }
            
            // Update unit positions immediately
            updateUnitModelPositions();
        }

        function updateAllUnitSizes() {
            gameState.units.forEach(unit => {
                if (unit.modelElement) {
                    const newSize = animalConfigs[unit.animal].size * devSettings.units.sizeMultiplier * 3;
                    const modelViewer = unit.modelElement.querySelector('model-viewer');
                    if (modelViewer) {
                        modelViewer.style.width = newSize + 'px';
                        modelViewer.style.height = newSize + 'px';
                    }
                }
            });
        }

        function regenerateGrid() {
            console.log('🔄 Regenerating grid with new settings...');
            
            // Clear existing grid
            gameMap = null;
            const container = document.getElementById('hex-grid');
            if (container) {
                container.innerHTML = '';
            }
            
            // Regenerate with new settings
            generateHexGrid(devSettings.grid.rows, devSettings.grid.cols);
            console.log(`✅ Grid regenerated: ${devSettings.grid.cols}x${devSettings.grid.rows}`);
        }

        function clearAllUnits() {
            console.log('🗑 Clearing all units...');
            gameState.units.forEach(unit => {
                if (unit.modelElement && unit.modelElement.parentNode) {
                    unit.modelElement.parentNode.removeChild(unit.modelElement);
                }
            });
            gameState.units = [];
            initializePopulationTracking();
            console.log('✅ All units cleared');
        }

        function spawnTestUnits() {
            console.log('➕ Spawning test units...');
            const testAnimals = ['bear', 'bee', 'frog'];
            testAnimals.forEach((animal, index) => {
                if (gameState.bases.length > index) {
                    spawnUnit(gameState.bases[index]);
                }
            });
        }

        function exportSettings() {
            const settings = JSON.stringify(devSettings, null, 2);
            console.log('💾 Current Development Settings:');
            console.log(settings);
            
            // Copy to clipboard if possible
            if (navigator.clipboard) {
                navigator.clipboard.writeText(settings).then(() => {
                    console.log('✅ Settings copied to clipboard');
                });
            }
        }

        function resetSettings() {
            console.log('🔄 Resetting to default settings...');
            
            // Reset dev settings to defaults
            devSettings = {
                globalCamera: { x: 0, y: 0, zoom: 1, rotation: 0, pitch: 0, yaw: 0, roll: 0 },
                tileCamera: { orbit: 0, elevation: 75, distance: 100 },
                grid: { 
                    cols: 12, rows: 16, 
                    tileWidth: 90, tileHeight: 120, 
                    columnGap: 0, rowGap: 0, hexOffset: 60 
                },
                terrain: {
                    mountainHeight: 120,
                    hillHeight: 80,
                    forestHeight: 40,
                    farmlandHeight: 5,
                    heightMultiplier: 1
                },
                units: { speedMultiplier: 1, sizeMultiplier: 1, spawnInterval: 15 },
                population: { maxPerTeam: 99, maxPerAnimal: 33, enableDeathSim: true },
                debug: { showCollision: false, showPath: false, showGrid: false }
            };
            
            // Update UI elements
            updateDevPanelUI();
            
            console.log('✅ Settings reset to defaults');
        }

        function updateDevPanelUI() {
            // Update all slider values to match current settings
            
            // Global Camera Controls
            document.getElementById('globalCameraX').value = devSettings.globalCamera.x;
            document.getElementById('globalCameraXValue').textContent = devSettings.globalCamera.x;
            document.getElementById('globalCameraY').value = devSettings.globalCamera.y;
            document.getElementById('globalCameraYValue').textContent = devSettings.globalCamera.y;
            document.getElementById('globalCameraZoom').value = devSettings.globalCamera.zoom;
            document.getElementById('globalCameraZoomValue').textContent = devSettings.globalCamera.zoom + 'x';
            document.getElementById('globalCameraRotation').value = devSettings.globalCamera.rotation;
            document.getElementById('globalCameraRotationValue').textContent = devSettings.globalCamera.rotation + '°';
            document.getElementById('globalCameraPitch').value = devSettings.globalCamera.pitch;
            document.getElementById('globalCameraPitchValue').textContent = devSettings.globalCamera.pitch + '°';
            document.getElementById('globalCameraYaw').value = devSettings.globalCamera.yaw;
            document.getElementById('globalCameraYawValue').textContent = devSettings.globalCamera.yaw + '°';
            document.getElementById('globalCameraRoll').value = devSettings.globalCamera.roll;
            document.getElementById('globalCameraRollValue').textContent = devSettings.globalCamera.roll + '°';
            
            // Tile Camera Controls
            document.getElementById('tileCameraOrbit').value = devSettings.tileCamera.orbit;
            document.getElementById('tileCameraOrbitValue').textContent = devSettings.tileCamera.orbit + '°';
            document.getElementById('tileCameraElevation').value = devSettings.tileCamera.elevation;
            document.getElementById('tileCameraElevationValue').textContent = devSettings.tileCamera.elevation + '°';
            document.getElementById('tileCameraDistance').value = devSettings.tileCamera.distance;
            document.getElementById('tileCameraDistanceValue').textContent = devSettings.tileCamera.distance + 'm';
            
            // Grid Controls
            document.getElementById('gridCols').value = devSettings.grid.cols;
            document.getElementById('gridColsValue').textContent = devSettings.grid.cols;
            document.getElementById('gridRows').value = devSettings.grid.rows;
            document.getElementById('gridRowsValue').textContent = devSettings.grid.rows;
            document.getElementById('tileWidth').value = devSettings.grid.tileWidth;
            document.getElementById('tileWidthValue').textContent = devSettings.grid.tileWidth + 'px';
            document.getElementById('tileHeight').value = devSettings.grid.tileHeight;
            document.getElementById('tileHeightValue').textContent = devSettings.grid.tileHeight + 'px';
            document.getElementById('hexOffset').value = devSettings.grid.hexOffset;
            document.getElementById('hexOffsetValue').textContent = devSettings.grid.hexOffset + 'px';
            document.getElementById('columnGap').value = devSettings.grid.columnGap;
            document.getElementById('columnGapValue').textContent = devSettings.grid.columnGap + 'px';
            document.getElementById('rowGap').value = devSettings.grid.rowGap;
            document.getElementById('rowGapValue').textContent = devSettings.grid.rowGap + 'px';
            
            // Terrain Controls
            document.getElementById('mountainHeight').value = devSettings.terrain.mountainHeight;
            document.getElementById('mountainHeightValue').textContent = devSettings.terrain.mountainHeight + 'px';
            document.getElementById('hillHeight').value = devSettings.terrain.hillHeight;
            document.getElementById('hillHeightValue').textContent = devSettings.terrain.hillHeight + 'px';
            document.getElementById('forestHeight').value = devSettings.terrain.forestHeight;
            document.getElementById('forestHeightValue').textContent = devSettings.terrain.forestHeight + 'px';
            document.getElementById('farmlandHeight').value = devSettings.terrain.farmlandHeight;
            document.getElementById('farmlandHeightValue').textContent = devSettings.terrain.farmlandHeight + 'px';
            document.getElementById('heightMultiplier').value = devSettings.terrain.heightMultiplier;
            document.getElementById('heightMultiplierValue').textContent = devSettings.terrain.heightMultiplier + 'x';
            
            // Unit Controls
            document.getElementById('unitSpeedMultiplier').value = devSettings.units.speedMultiplier;
            document.getElementById('unitSpeedMultiplierValue').textContent = devSettings.units.speedMultiplier + 'x';
            document.getElementById('unitSizeMultiplier').value = devSettings.units.sizeMultiplier;
            document.getElementById('unitSizeMultiplierValue').textContent = devSettings.units.sizeMultiplier + 'x';
            document.getElementById('spawnInterval').value = devSettings.units.spawnInterval;
            document.getElementById('spawnIntervalValue').textContent = devSettings.units.spawnInterval + 's';
            
            // Population Controls
            document.getElementById('maxPerTeam').value = devSettings.population.maxPerTeam;
            document.getElementById('maxPerTeamValue').textContent = devSettings.population.maxPerTeam;
            document.getElementById('maxPerAnimal').value = devSettings.population.maxPerAnimal;
            document.getElementById('maxPerAnimalValue').textContent = devSettings.population.maxPerAnimal;
            document.getElementById('enableDeathSim').checked = devSettings.population.enableDeathSim;
            
            // Debug Controls
            document.getElementById('showCollisionDebug').checked = devSettings.debug.showCollision;
            document.getElementById('showPathDebug').checked = devSettings.debug.showPath;
            document.getElementById('showGridDebug').checked = devSettings.debug.showGrid;
            
            // Update camera and game state
            gameState.camera.x = devSettings.globalCamera.x;
            gameState.camera.y = devSettings.globalCamera.y;
            updateGlobalCameraPosition();
        }

        function render() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Save context for camera transform
            ctx.save();
            ctx.translate(-gameState.camera.x, -gameState.camera.y);

            // Draw bases
            gameState.bases.forEach(base => {
                const config = animalConfigs[base.animal];
                
                // Base structure
                ctx.fillStyle = '#4a4a4a';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                
                // Different base shapes based on animal
                if (config.baseStyle === 'hive') {
                    drawHexagon(ctx, base.x, base.y, base.size);
                } else if (config.baseStyle === 'pond') {
                    ctx.beginPath();
                    ctx.arc(base.x, base.y, base.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.fillRect(base.x - base.size/2, base.y - base.size/2, base.size, base.size);
                    ctx.strokeRect(base.x - base.size/2, base.y - base.size/2, base.size, base.size);
                }

                // Base emoji
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#fff';
                ctx.fillText(config.emoji, base.x, base.y + 8);
            });

            // Draw movement target indicators for selected units
            gameState.selectedUnits.forEach(unit => {
                if (unit.isMoving && unit.targetX && unit.targetY) {
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(unit.x, unit.y);
                    ctx.lineTo(unit.targetX, unit.targetY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Target marker
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.arc(unit.targetX, unit.targetY, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.restore();

            // Draw mini-map
            renderMiniMap();
        }

        function drawHexagon(ctx, x, y, size) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                const px = x + Math.cos(angle) * size;
                const py = y + Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function renderMiniMap() {
            const miniCanvas = document.getElementById('miniMapCanvas');
            const miniCtx = miniCanvas.getContext('2d');
            
            // Clear mini-map
            miniCtx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);
            
            const scaleX = miniCanvas.width / gameState.mapSize.width;
            const scaleY = miniCanvas.height / gameState.mapSize.height;

            // Draw bases on mini-map
            gameState.bases.forEach(base => {
                miniCtx.fillStyle = '#4a4a4a';
                miniCtx.fillRect(
                    base.x * scaleX - 2, 
                    base.y * scaleY - 2, 
                    4, 4
                );
            });

            // Draw units on mini-map
            gameState.units.forEach(unit => {
                miniCtx.fillStyle = gameState.selectedUnits.includes(unit) ? '#00ff88' : '#ffffff';
                miniCtx.fillRect(
                    unit.x * scaleX - 1, 
                    unit.y * scaleY - 1, 
                    2, 2
                );
            });

            // Draw camera view
            const cameraX = gameState.camera.x * scaleX;
            const cameraY = gameState.camera.y * scaleY;
            const cameraW = window.innerWidth * scaleX;
            const cameraH = window.innerHeight * scaleY;
            
            miniCtx.strokeStyle = '#fff';
            miniCtx.lineWidth = 1;
            miniCtx.strokeRect(cameraX, cameraY, cameraW, cameraH);
        }

        function gameLoop() {
            if (!gameState.gameStarted) return;

            const currentTime = Date.now();
            const deltaTime = currentTime - (gameState.lastTime || currentTime);
            gameState.lastTime = currentTime;

            // Manage population with intelligent spawning
            managePopulation();

            // Simulate unit deaths (temporary - for testing population management)
            // Remove this section when implementing actual combat
            if (devSettings.population.enableDeathSim && Math.random() < 0.001 && gameState.units.length > 6) { // 0.1% chance per frame if more than 6 units
                const randomUnit = gameState.units[Math.floor(Math.random() * gameState.units.length)];
                console.log(`⚔️ Simulated death: ${randomUnit.animal} (${randomUnit.team})`);
                removeUnit(randomUnit);
            }

            // Update units
            updateUnits(deltaTime);

            // Render
            render();

            // Continue game loop
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html> 