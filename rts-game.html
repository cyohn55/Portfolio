<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animal RTS - Choose Your Army</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow: visible;
            height: 100%;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: visible;
            height: 100%;
            position: relative;
        }

        /* Title Screen */
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #titleScreen h1 {
            color: white;
            font-size: 3rem;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #titleScreen p {
            color: white;
            font-size: 1.2rem;
            margin-bottom: 3rem;
            text-align: center;
        }

        .animal-selection {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 800px;
        }

        .animal-card {
            background: rgba(255,255,255,0.1);
            border: 3px solid transparent;
            border-radius: 15px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 120px;
            text-align: center;
        }

        .animal-card:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-5px);
        }

        .animal-card.selected {
            border-color: #00ff88;
            background: rgba(0,255,136,0.2);
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }

        .animal-card h3 {
            color: white;
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        .animal-card p {
            color: rgba(255,255,255,0.8);
            font-size: 0.8rem;
            margin: 0;
        }

        .start-btn {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.5;
            pointer-events: none;
        }

        .start-btn.enabled {
            opacity: 1;
            pointer-events: all;
        }

        .start-btn:hover.enabled {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,255,136,0.4);
        }

        /* Game Screen */
        #gameScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            cursor: crosshair;
            position: relative;
            z-index: 1;
        }

        /* 3D Models Container */
        #modelsContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .unit-model {
            position: absolute;
            pointer-events: none;
            z-index: 15;
        }

        .unit-model model-viewer {
            width: 100%;
            height: 100%;
            --progress-bar-display: none;
        }

        .unit-model.selected model-viewer {
            filter: drop-shadow(0 0 10px #00ff88);
        }

        /* Hex Grid Terrain System */
        #hexGridContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            opacity: 0.8;
        }

        #hex-grid {
            position: absolute;
            top: 50px;
            left: 50px;
            width: 100%;
            height: 100%;
            --hex-tile-size: 180px; /* Tripled from 60px */
            /* StarCraft-style 30-degree viewing angle for the entire hex grid */
            transform: perspective(2000px) rotateX(30deg);
            transform-origin: center top;
        }

        /* Removed rotation - all tiles maintain same orientation */

        .hex-tile {
            background: transparent;
            border: none;
            --progress-bar-display: none;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Performance optimizations */
            will-change: transform;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            transition: transform 0.2s ease;
            /* Create hexagonal shape using clip-path - larger hexagon for tighter gaps */
            clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
        }

        .hex-tile:hover {
            transform: scale(1.05);
            z-index: 10;
        }

        /* Static tile styling - now all tiles are 3D models */
        .hex-tile.mountain {
            filter: brightness(0.9); /* Slightly darker for visual distinction */
        }

        .hex-tile.hill {
            filter: brightness(0.95); /* Slightly darker for visual distinction */
        }

        .hex-tile:hover {
            filter: brightness(1.1) saturate(1.2); /* Highlight on hover */
        }

        /* Visual feedback for terrain traversability */
        .hex-tile.non-traversable {
            cursor: not-allowed;
        }

        .hex-tile.traversable {
            cursor: pointer;
        }

        .hex-tile model-viewer {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }

        /* UI Elements */
        .ui-panel {
            position: absolute;
            background: rgba(0,0,0,0.8);
            border-radius: 10px;
            padding: 1rem;
            color: white;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        #resourcePanel {
            top: 20px;
            left: 20px;
        }

        #controlPanel {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
        }

        .animal-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 0.5rem 1rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .animal-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.5);
        }

        .animal-btn.active {
            background: rgba(0,255,136,0.3);
            border-color: #00ff88;
        }

        #selectionBox {
            position: absolute;
            border: 2px dashed #00ff88;
            background: rgba(0,255,136,0.1);
            pointer-events: none;
            display: none;
            z-index: 50;
        }

        /* Mini-map */
        #miniMap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
        }

        /* Loading indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            z-index: 1001;
        }
    </style>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
</head>
<body>
    <!-- Title Screen -->
    <div id="titleScreen">
        <h1>üéÆ Animal RTS</h1>
        <p>Choose 3 animals to build your army and conquer the battlefield!</p>
        
        <div class="animal-selection">
            <div class="animal-card" data-animal="bear">
                <h3>üêª Bear</h3>
                <p>Strong & Durable<br>Slow but powerful units</p>
            </div>
            <div class="animal-card" data-animal="bee">
                <h3>üêù Bee</h3>
                <p>Fast & Agile<br>Quick swarm attacks</p>
            </div>
            <div class="animal-card" data-animal="turtle">
                <h3>üê¢ Turtle</h3>
                <p>Defensive<br>High armor, steady advance</p>
            </div>
            <div class="animal-card" data-animal="fox">
                <h3>ü¶ä Fox</h3>
                <p>Cunning & Quick<br>Hit and run tactics</p>
            </div>
            <div class="animal-card" data-animal="frog">
                <h3>üê∏ Frog</h3>
                <p>Amphibious<br>Can cross water</p>
            </div>
            <div class="animal-card" data-animal="owl">
                <h3>ü¶â Owl</h3>
                <p>Air Support<br>Flying reconnaissance</p>
            </div>
            <div class="animal-card" data-animal="pig">
                <h3>üê∑ Pig</h3>
                <p>Resource Gatherer<br>Boosts economy</p>
            </div>
            <div class="animal-card" data-animal="cat">
                <h3>üê± Cat</h3>
                <p>Stealth Hunter<br>Invisible attacks</p>
            </div>
            <div class="animal-card" data-animal="chicken">
                <h3>üêî Chicken</h3>
                <p>Rapid Breeder<br>Fast unit production</p>
            </div>
            <div class="animal-card" data-animal="dolphin">
                <h3>üê¨ Dolphin</h3>
                <p>Naval Unit<br>Controls waterways</p>
            </div>
        </div>
        
        <button class="start-btn" id="startBtn">Start Game</button>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen">
        <canvas id="gameCanvas"></canvas>
        
        <!-- 3D Models Container -->
        <div id="modelsContainer"></div>
        
        <!-- Hex Grid Terrain Container -->
        <div id="hexGridContainer">
            <div id="hex-grid"></div>
        </div>
        
        <!-- UI Panels -->
        <div id="resourcePanel" class="ui-panel">
            <div>Population: <span id="population">0</span></div>
            <div>Selected: <span id="selectedCount">0</span></div>
        </div>

        <div id="controlPanel" class="ui-panel">
            <!-- Animal control buttons will be dynamically added here -->
        </div>

        <div id="miniMap" class="ui-panel">
            <canvas id="miniMapCanvas" width="200" height="150"></canvas>
        </div>

        <div id="selectionBox"></div>
    </div>

    <div class="loading" id="loadingIndicator" style="display: none;">Loading 3D Models...</div>

    <script>
        // Game State
        let gameState = {
            selectedAnimals: [],
            units: [],
            bases: [],
            selectedUnits: [],
            gameStarted: false,
            population: 0,
            lastSpawnTime: 0,
            camera: { x: 0, y: 0 },
            isSelecting: false,
            selectionStart: { x: 0, y: 0 },
            mapSize: { width: 2000, height: 1500 },
            modelsLoaded: false
        };

        // Animal configurations with 3D model paths
        const animalConfigs = {
            bear: { speed: 1, size: 40, model: 'models/Bear.glb', baseStyle: 'cave', emoji: 'üêª' },
            bee: { speed: 3, size: 20, model: 'models/Bee.glb', baseStyle: 'hive', emoji: 'üêù' },
            turtle: { speed: 0.5, size: 35, model: 'models/Turtle.glb', baseStyle: 'pond', emoji: 'üê¢' },
            fox: { speed: 2.5, size: 25, model: 'models/Fox.glb', baseStyle: 'den', emoji: 'ü¶ä' },
            frog: { speed: 2, size: 22, model: 'models/Frog.glb', baseStyle: 'lily', emoji: 'üê∏' },
            owl: { speed: 2, size: 30, model: 'models/Owl.glb', baseStyle: 'tree', emoji: 'ü¶â' },
            pig: { speed: 1.5, size: 28, model: 'models/Pig.glb', baseStyle: 'pen', emoji: 'üê∑' },
            cat: { speed: 2.2, size: 24, model: 'models/cat.glb', baseStyle: 'house', emoji: 'üê±' },
            chicken: { speed: 1.8, size: 20, model: 'models/Chicken.glb', baseStyle: 'coop', emoji: 'üêî' },
            dolphin: { speed: 2.5, size: 38, model: 'models/dolphin.glb', baseStyle: 'pool', emoji: 'üê¨' }
        };

        /* --------------------
           Phase 0 ‚Äì Ground-rules & Tile Legend (two-player map)
        ---------------------*/

        // Single source of truth for every terrain / base tile
        const TileType = Object.freeze({
            PLAYER_BASE:   'playerBase',   // b ‚Äì will be bound to chosen animals later
            ENEMY_BASE:    'enemyBase',    // e ‚Äì NPC bases
            MOUNTAIN:      'mountain',     // m
            LAKE:          'lake',         // l (clusters post-processed ‚Üí river/ocean)
            RIVER:         'river',        // r
            OCEAN:         'ocean',        // o
            FARMLAND:      'farmland',     // f
            WETLAND:       'wetland',      // w
            PLAIN:         'plain'         // p (default)
        });

        // Mapping from CSV character to TileType for quick parsing (Phase 1 will use this)
        const TILE_CHAR = Object.freeze({
            'b': TileType.PLAYER_BASE,
            'e': TileType.ENEMY_BASE,
            'm': TileType.MOUNTAIN,
            'l': TileType.LAKE,
            'r': TileType.RIVER,
            'o': TileType.OCEAN,
            'f': TileType.FARMLAND,
            'w': TileType.WETLAND,
            'p': TileType.PLAIN,
            '':  TileType.PLAIN
        });

        // Two-team setup: human player vs single NPC (AI)
        const Teams = Object.freeze({
            PLAYER: 'player',
            NPC:    'enemy'   // retains previous naming for compatibility
        });

        // Hex grid terrain system
        const hexTileModels = [
            { file: 'models/Mountain.glb', alt: 'Mountain Tile' },
            { file: 'models/Forest.glb', alt: 'Forest Tile' },
            { file: 'models/Hill.glb', alt: 'Hill Tile' },
            { file: 'models/FarmLand.glb', alt: 'Farm Land Tile' }
        ];

        // Game map cache to avoid regeneration
        let gameMap = null;
                
                // Helper function to check if a tile is traversable by a specific animal
        function isTileTraversable(x, y, animalType = null) {
            if (!gameMap || x < 0 || y < 0 || x >= gameMap.length || y >= gameMap[0].length) {
                return false; // Out of bounds
            }
            
            const tile = gameMap[x][y];
            
            // Flying animals (Owl and Bee) can traverse all terrain including Mountains/Hills
            if (animalType === 'owl' || animalType === 'bee') {
                return true;
            }
            
            // Ground animals cannot traverse Mountains or Hills
            if (tile.file.includes('Mountain') || tile.file.includes('Hill')) {
                return false;
            }
            
            // All other terrain (FarmLand, Forest) is traversable by ground animals
            return true;
        }

        // Convert screen coordinates to hex grid coordinates with proper offset handling
        function screenToHex(x, y) {
            const hexX = Math.floor(x / 90);
            let hexY = Math.floor(y / 120);
            
            // Adjust for hex offset on odd columns
            if (hexX % 2 === 1) {
                hexY = Math.floor((y - 60) / 120);
            }
            
            return { x: hexX, y: hexY };
        }

        // Convert hex coordinates to screen coordinates (center of tile)
        function hexToScreen(hexX, hexY) {
            let screenX = hexX * 90 + 45; // Center of tile
            let screenY = hexY * 120 + 60; // Center of tile
            
            // Adjust for hex offset on odd columns
            if (hexX % 2 === 1) {
                screenY += 60;
            }
            
            return { x: screenX, y: screenY };
        }

        // Check if a specific screen position is within a non-traversable hex tile
        function isPositionBlocked(screenX, screenY, animalType) {
            const hex = screenToHex(screenX, screenY);
            return !isTileTraversable(hex.x, hex.y, animalType);
        }

        // Get hex tile boundaries for collision detection
        function getHexBounds(hexX, hexY) {
            const center = hexToScreen(hexX, hexY);
            const size = 60; // Half of tile size (120/2)
            
            return {
                centerX: center.x,
                centerY: center.y,
                minX: center.x - size,
                maxX: center.x + size,
                minY: center.y - size,
                maxY: center.y + size,
                size: size
            };
        }

        // Check if a unit position would collide with hex tile boundaries
        function checkHexCollision(unitX, unitY, animalType) {
            const hex = screenToHex(unitX, unitY);
            
            // Get all adjacent hexes using proper hex grid neighbors
            const neighborsToCheck = getNeighbors(hex.x, hex.y);
            neighborsToCheck.push([hex.x, hex.y]); // Include current hex
            
            for (const [tileX, tileY] of neighborsToCheck) {
                if (!isTileTraversable(tileX, tileY, animalType)) {
                    const bounds = getHexBounds(tileX, tileY);
                    const distance = Math.sqrt(
                        Math.pow(unitX - bounds.centerX, 2) + 
                        Math.pow(unitY - bounds.centerY, 2)
                    );
                    
                    // Check if unit is too close to the hex center (collision)
                    // Use 70% of hex radius for tighter boundary control
                    if (distance < bounds.size * 0.7) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Keep units constrained to the center areas of traversable hexes
        function constrainUnitToHex(unitX, unitY, animalType) {
            const hex = screenToHex(unitX, unitY);
            
            // If current hex is not traversable, try to move to nearest traversable hex
            if (!isTileTraversable(hex.x, hex.y, animalType)) {
                const nearestTraversable = findNearestTraversableTile(hex.x, hex.y, animalType);
                if (nearestTraversable) {
                    const centerPos = hexToScreen(nearestTraversable.x, nearestTraversable.y);
                    return { x: centerPos.x, y: centerPos.y };
                }
            }
            
            // Keep unit closer to hex center to prevent edge-walking
            const centerPos = hexToScreen(hex.x, hex.y);
            const dx = unitX - centerPos.x;
            const dy = unitY - centerPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistanceFromCenter = 45; // 75% of hex radius (60 * 0.75)
            
            if (distance > maxDistanceFromCenter) {
                const ratio = maxDistanceFromCenter / distance;
                return {
                    x: centerPos.x + dx * ratio,
                    y: centerPos.y + dy * ratio
                };
            }
            
            return { x: unitX, y: unitY };
        }
            
        // Get tile type at position (for gameplay logic)
        function getTileAt(x, y) {
            if (!gameMap || x < 0 || y < 0 || x >= gameMap.length || y >= gameMap[0].length) {
                return null;
            }
            return gameMap[x][y];
        }

        function getRandomHexTile() {
            // Weighted terrain generation - reduce Mountains/Hills by 25%
            const terrainWeights = [
                { tile: hexTileModels[0], weight: 0.1875 }, // Mountain: reduced from 0.25 to 0.1875 (-25%)
                { tile: hexTileModels[1], weight: 0.375 },  // Forest: 37.5%
                { tile: hexTileModels[2], weight: 0.1875 }, // Hill: reduced from 0.25 to 0.1875 (-25%)
                { tile: hexTileModels[3], weight: 0.25 }    // FarmLand: 25%
            ];
            
            const totalWeight = terrainWeights.reduce((sum, item) => sum + item.weight, 0);
            let random = Math.random() * totalWeight;
            
            for (const item of terrainWeights) {
                random -= item.weight;
                if (random <= 0) {
                    return item.tile;
                }
            }
            
            // Fallback to Forest if something goes wrong
            return hexTileModels[1];
        }

        // Generate a static map layout once
        function generateMapLayout(rows = 16, cols = 20) {
            if (gameMap) return gameMap; // Return cached map if exists
            
            gameMap = [];
            for (let i = 0; i < cols; i++) {
                gameMap[i] = [];
                for (let j = 0; j < rows; j++) {
                    const tileData = getRandomHexTile();
                    gameMap[i][j] = {
                        ...tileData,
                        x: i,
                        y: j,
                        // Keep terrain type for traversal logic, but render all as 3D models for visibility
                        terrainType: tileData.file.includes('Mountain') ? 'mountain' : 
                                   tileData.file.includes('Hill') ? 'hill' :
                                   tileData.file.includes('FarmLand') ? 'farmland' : 'forest',
                        isStatic: false // All tiles render as 3D models for visibility
                    };
                }
            }
            return gameMap;
        }

        function generateHexGrid(rows = 16, cols = 20) {
            const container = document.getElementById('hex-grid');
            if (!container) {
                console.warn('Hex grid container (#hex-grid) not found.');
                return;
            }

            // Clear any existing tiles
            container.innerHTML = '';

            // Generate or use cached map layout
            const mapLayout = generateMapLayout(rows, cols);
            
            // Count different terrain types for info
            let mountainCount = 0, hillCount = 0, farmlandCount = 0, forestCount = 0;
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    switch(mapLayout[i][j].terrainType) {
                        case 'mountain': mountainCount++; break;
                        case 'hill': hillCount++; break;
                        case 'farmland': farmlandCount++; break;
                        case 'forest': forestCount++; break;
                    }
                }
            }
            console.log(`Generated map terrain: ${mountainCount} Mountains, ${hillCount} Hills, ${farmlandCount} Farmland, ${forestCount} Forest`);
            console.log(`Traversability: Mountains/Hills block ground animals, all terrain allows flying animals (Owl/Bee)`);

            // Overlapping containers to eliminate visual gaps between hexagonal models
            const hexWidth = 90;  // Tripled from 30
            const hexHeight = 120; // Tripled from 40
            const hexOffset = 60;  // Tripled from 20

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const tileData = mapLayout[i][j];
                    
                    // Calculate position
                    let xPos, yPos;
                    if (i % 2 === 0) {
                        xPos = i * hexWidth;
                        yPos = j * hexHeight;
                    } else {
                        xPos = i * hexWidth;
                        yPos = j * hexHeight + hexOffset;
                    }

                    // All tiles are now 3D models for visibility
                    createTerrainTile(tileData, xPos, yPos, container);
                    }
            }
        }

        function createTerrainTile(tileData, xPos, yPos, container) {
            const tile = document.createElement('model-viewer');
            tile.classList.add('hex-tile', tileData.terrainType);
            tile.setAttribute('src', tileData.file);
            tile.setAttribute('alt', tileData.alt);
            tile.setAttribute('interaction-prompt', 'none');
            tile.setAttribute('loading', 'lazy');
            tile.setAttribute('reveal', 'manual');
            tile.setAttribute('camera-orbit', '0deg 0deg 150m');
            tile.setAttribute('field-of-view', '20deg');
            tile.setAttribute('rotation', '0deg 0deg 0deg');
            tile.setAttribute('disable-zoom', '');
            tile.setAttribute('disable-pan', '');
            tile.setAttribute('min-camera-orbit', '0deg 0deg 150m');
            tile.setAttribute('max-camera-orbit', '0deg 0deg 150m');
            
            // Store tile coordinates for traversability checking
            tile.dataset.hexX = Math.floor(xPos / 90);
            tile.dataset.hexY = Math.floor(yPos / 120);
            
            // Add traversability info for visual feedback
            if (tileData.terrainType === 'mountain' || tileData.terrainType === 'hill') {
                tile.title = `${tileData.terrainType} (Ground animals cannot pass, Flying animals can pass)`;
            } else {
                tile.title = `${tileData.terrainType} (All animals can pass)`;
            }
            
            tile.style.position = 'absolute';
            tile.style.left = xPos + 'px';
            tile.style.top = yPos + 'px';
            tile.style.width = '120px';  // Tripled from 40px
            tile.style.height = '120px'; // Tripled from 40px
            
            container.appendChild(tile);
            
            // Load all tiles immediately since we're back to 3D models for visibility
            tile.dismissPoster();
        }

        // Performance: Progressive loading with Intersection Observer
        function setupProgressiveLoading() {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const tile = entry.target;
                        if (tile.hasAttribute('reveal')) {
                            tile.dismissPoster();
                            observer.unobserve(tile);
                        }
                    }
                });
            }, {
                rootMargin: '100px' // Load tiles 100px before they come into view
            });

            // Observe all hex tiles for progressive loading
            document.querySelectorAll('.hex-tile').forEach(tile => {
                if (tile.hasAttribute('reveal')) {
                    observer.observe(tile);
                        }
                    });
        }

        // Title Screen Logic
        document.addEventListener('DOMContentLoaded', function() {
            const animalCards = document.querySelectorAll('.animal-card');
            const startBtn = document.getElementById('startBtn');

            animalCards.forEach(card => {
                card.addEventListener('click', function() {
                    const animal = this.dataset.animal;
                    
                    if (this.classList.contains('selected')) {
                        this.classList.remove('selected');
                        gameState.selectedAnimals = gameState.selectedAnimals.filter(a => a !== animal);
                    } else if (gameState.selectedAnimals.length < 3) {
                        this.classList.add('selected');
                        gameState.selectedAnimals.push(animal);
                    }

                    // Update start button
                    if (gameState.selectedAnimals.length === 3) {
                        startBtn.classList.add('enabled');
                        startBtn.textContent = `Start with ${gameState.selectedAnimals.map(a => animalConfigs[a].emoji).join(' ')}`;
                    } else {
                        startBtn.classList.remove('enabled');
                        startBtn.textContent = `Select ${3 - gameState.selectedAnimals.length} more animals`;
                    }
                });
            });

            startBtn.addEventListener('click', function() {
                if (gameState.selectedAnimals.length === 3) {
                    startGame();
                }
            });
        });

        function startGame() {
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            document.getElementById('loadingIndicator').style.display = 'block';
            gameState.gameStarted = true;

            // Preload models then initialize game
            preloadModels().then(() => {
                document.getElementById('loadingIndicator').style.display = 'none';
                initializeGame();
                // No tree initialization needed
                gameLoop();
            });
        }

        async function preloadModels() {
            const modelsToLoad = gameState.selectedAnimals.map(animal => animalConfigs[animal].model);
            // No additional models to preload
            
            // Create invisible model-viewers to preload
            const preloadContainer = document.createElement('div');
            preloadContainer.style.position = 'absolute';
            preloadContainer.style.top = '-1000px';
            preloadContainer.style.left = '-1000px';
            document.body.appendChild(preloadContainer);

            const loadPromises = modelsToLoad.map(modelPath => {
                return new Promise((resolve, reject) => {
                    const modelViewer = document.createElement('model-viewer');
                    modelViewer.src = modelPath;
                    modelViewer.style.width = '1px';
                    modelViewer.style.height = '1px';
                    
                    modelViewer.addEventListener('load', () => {
                        resolve();
                    });
                    
                    modelViewer.addEventListener('error', () => {
                        console.warn(`Failed to load model: ${modelPath}`);
                        resolve(); // Continue even if model fails to load
                    });
                    
                    preloadContainer.appendChild(modelViewer);
                    
                    // Timeout fallback
                    setTimeout(() => resolve(), 3000);
                });
            });

            await Promise.all(loadPromises);
            document.body.removeChild(preloadContainer);
            gameState.modelsLoaded = true;
        }

        function initializeGame() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Generate hex grid terrain
            generateHexGrid();
            
            // Setup progressive loading for better performance
            setTimeout(() => setupProgressiveLoading(), 100);

            // Create bases for selected animals
            gameState.selectedAnimals.forEach((animal, index) => {
                const base = {
                    animal: animal,
                    team: 'player',
                    x: 200 + (index * 150),
                    y: 200,
                    lastSpawn: 0,
                    spawnInterval: 15000, // 15 seconds
                    size: 40
                };
                gameState.bases.push(base);
            });

            // Create enemy bases with 3 random remaining animals
            const remainingAnimals = Object.keys(animalConfigs).filter(a => !gameState.selectedAnimals.includes(a));
            // Shuffle simple
            for (let i = remainingAnimals.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [remainingAnimals[i], remainingAnimals[j]] = [remainingAnimals[j], remainingAnimals[i]];
            }
            const enemyAnimals = remainingAnimals.slice(0, 3);

            enemyAnimals.forEach((animal, index) => {
                const base = {
                    animal: animal,
                    team: 'enemy',
                    x: gameState.mapSize.width - (200 + (index * 150)),
                    y: gameState.mapSize.height - 200,
                    lastSpawn: 0,
                    spawnInterval: 15000,
                    size: 40
                };
                gameState.bases.push(base);
            });

            // Create control buttons
            createControlButtons();

            // Add event listeners
            setupEventListeners();
        }

        function createControlButtons() {
            const controlPanel = document.getElementById('controlPanel');
            controlPanel.innerHTML = '';

            gameState.selectedAnimals.forEach(animal => {
                const btn = document.createElement('button');
                btn.className = 'animal-btn';
                btn.textContent = `Select All ${animalConfigs[animal].emoji}`;
                btn.dataset.animal = animal;
                btn.addEventListener('click', () => selectAllUnitsOfType(animal));
                controlPanel.appendChild(btn);
            });
        }

        function setupEventListeners() {
            const canvas = document.getElementById('gameCanvas');

            // Mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);

            // Window resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                updateUnitModelPositions();
            });
        }

        function handleMouseDown(e) {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left + gameState.camera.x;
            const y = e.clientY - rect.top + gameState.camera.y;

            if (e.button === 0) { // Left click
                startSelection(x, y);
            } else if (e.button === 2) { // Right click
                moveSelectedUnits(x, y);
            }
        }

        function handleMouseMove(e) {
            if (gameState.isSelecting) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left + gameState.camera.x;
                const y = e.clientY - rect.top + gameState.camera.y;
                updateSelection(x, y);
            }
        }

        function handleMouseUp(e) {
            if (gameState.isSelecting) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left + gameState.camera.x;
                const y = e.clientY - rect.top + gameState.camera.y;
                finishSelection(x, y);
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = e.target.getBoundingClientRect();
            const x = touch.clientX - rect.left + gameState.camera.x;
            const y = touch.clientY - rect.top + gameState.camera.y;
            
            startSelection(x, y);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (gameState.isSelecting && e.touches.length === 1) {
                const touch = e.touches[0];
                const rect = e.target.getBoundingClientRect();
                const x = touch.clientX - rect.left + gameState.camera.x;
                const y = touch.clientY - rect.top + gameState.camera.y;
                updateSelection(x, y);
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (gameState.isSelecting) {
                if (e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    const rect = e.target.getBoundingClientRect();
                    const x = touch.clientX - rect.left + gameState.camera.x;
                    const y = touch.clientY - rect.top + gameState.camera.y;
                    finishSelection(x, y);
                }
            }
        }

        function startSelection(x, y) {
            // Check if clicking on a unit first
            const clickedUnit = gameState.units.find(unit => {
                const dx = unit.x - x;
                const dy = unit.y - y;
                return Math.sqrt(dx * dx + dy * dy) < unit.size;
            });

            if (clickedUnit) {
                // Single unit selection
                gameState.selectedUnits = [clickedUnit];
                updateSelectedCount();
                updateUnitSelectionVisuals();
            } else {
                // Start box selection
                gameState.isSelecting = true;
                gameState.selectionStart = { x, y };
                gameState.selectedUnits = [];
                updateSelectedCount();
                updateUnitSelectionVisuals();
            }
        }

        function updateSelection(x, y) {
            const selectionBox = document.getElementById('selectionBox');
            const canvas = document.getElementById('gameCanvas');
            
            const startX = Math.min(gameState.selectionStart.x - gameState.camera.x, x - gameState.camera.x);
            const startY = Math.min(gameState.selectionStart.y - gameState.camera.y, y - gameState.camera.y);
            const width = Math.abs(x - gameState.selectionStart.x);
            const height = Math.abs(y - gameState.selectionStart.y);

            selectionBox.style.left = startX + 'px';
            selectionBox.style.top = startY + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
            selectionBox.style.display = 'block';
        }

        function finishSelection(x, y) {
            gameState.isSelecting = false;
            document.getElementById('selectionBox').style.display = 'none';

            // Find units within selection box
            const minX = Math.min(gameState.selectionStart.x, x);
            const maxX = Math.max(gameState.selectionStart.x, x);
            const minY = Math.min(gameState.selectionStart.y, y);
            const maxY = Math.max(gameState.selectionStart.y, y);

            gameState.selectedUnits = gameState.units.filter(unit => 
                unit.team === 'player' &&
                unit.x >= minX && unit.x <= maxX && 
                unit.y >= minY && unit.y <= maxY
            );

            updateSelectedCount();
            updateUnitSelectionVisuals();
        }

        function moveSelectedUnits(x, y) {
            if (gameState.selectedUnits.length > 0) {
                // Create formation around target point
                const formationRadius = Math.sqrt(gameState.selectedUnits.length) * 20;
                
                gameState.selectedUnits.forEach((unit, index) => {
                    const angle = (index / gameState.selectedUnits.length) * Math.PI * 2;
                    const offsetX = Math.cos(angle) * formationRadius;
                    const offsetY = Math.sin(angle) * formationRadius;
                    
                    const targetX = x + offsetX;
                    const targetY = y + offsetY;
                    
                    // Use A* pathfinding for optimal route finding
                    setUnitPath(unit, targetX, targetY);
                });
            }
        }

        // Find the nearest traversable tile for an animal
        function findNearestTraversableTile(startX, startY, animalType) {
            const maxSearchRadius = 5; // Limit search to prevent performance issues
            
            for (let radius = 1; radius <= maxSearchRadius; radius++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        const checkX = startX + dx;
                        const checkY = startY + dy;
                        
                        if (isTileTraversable(checkX, checkY, animalType)) {
                            return { x: checkX, y: checkY };
                        }
                    }
                }
            }
            return null; // No traversable tile found within search radius
        }

        // A* Pathfinding Implementation
        class AStarNode {
            constructor(x, y, gCost = 0, hCost = 0, parent = null) {
                this.x = x;
                this.y = y;
                this.gCost = gCost; // Distance from start
                this.hCost = hCost; // Heuristic distance to goal
                this.fCost = gCost + hCost; // Total cost
                this.parent = parent;
            }
            
            equals(other) {
                return this.x === other.x && this.y === other.y;
            }
        }

        function findPathAStar(startX, startY, goalX, goalY, animalType) {
            const openSet = [];
            const closedSet = [];
            const startNode = new AStarNode(startX, startY, 0, heuristic(startX, startY, goalX, goalY));
            
            openSet.push(startNode);
            
            while (openSet.length > 0) {
                // Find node with lowest fCost
                let currentNode = openSet[0];
                let currentIndex = 0;
                
                for (let i = 1; i < openSet.length; i++) {
                    if (openSet[i].fCost < currentNode.fCost || 
                        (openSet[i].fCost === currentNode.fCost && openSet[i].hCost < currentNode.hCost)) {
                        currentNode = openSet[i];
                        currentIndex = i;
                    }
                }
                
                // Move current from open to closed
                openSet.splice(currentIndex, 1);
                closedSet.push(currentNode);
                
                // Check if we reached the goal
                if (currentNode.x === goalX && currentNode.y === goalY) {
                    return reconstructPath(currentNode);
                }
                
                // Check all neighbors
                const neighbors = getNeighbors(currentNode.x, currentNode.y);
                for (const neighbor of neighbors) {
                    const [nx, ny] = neighbor;
                    
                    // Skip if not traversable or already in closed set
                    if (!isTileTraversable(nx, ny, animalType) || 
                        closedSet.some(node => node.x === nx && node.y === ny)) {
                        continue;
                    }
                    
                    const gCost = currentNode.gCost + getMovementCost(currentNode.x, currentNode.y, nx, ny);
                    const hCost = heuristic(nx, ny, goalX, goalY);
                    const neighborNode = new AStarNode(nx, ny, gCost, hCost, currentNode);
                    
                    // Check if this path to neighbor is better
                    const existingIndex = openSet.findIndex(node => node.x === nx && node.y === ny);
                    if (existingIndex === -1) {
                        openSet.push(neighborNode);
                    } else if (gCost < openSet[existingIndex].gCost) {
                        openSet[existingIndex] = neighborNode;
                    }
                }
            }
            
            return null; // No path found
        }

        function heuristic(x1, y1, x2, y2) {
            // Manhattan distance for hex grid
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            return dx + dy;
        }

        function getMovementCost(x1, y1, x2, y2) {
            // Basic movement cost - can be enhanced with terrain-specific costs
            return 1;
        }

        function getNeighbors(x, y) {
            // Hex grid neighbors (6 directions)
            if (x % 2 === 0) { // Even column
                return [
                    [x, y-1],     // North
                    [x+1, y-1],   // Northeast
                    [x+1, y],     // Southeast
                    [x, y+1],     // South
                    [x-1, y],     // Southwest
                    [x-1, y-1]    // Northwest
                ];
            } else { // Odd column
                return [
                    [x, y-1],     // North
                    [x+1, y],     // Northeast
                    [x+1, y+1],   // Southeast
                    [x, y+1],     // South
                    [x-1, y+1],   // Southwest
                    [x-1, y]      // Northwest
                ];
            }
        }

        function reconstructPath(goalNode) {
            const path = [];
            let current = goalNode;
            
            while (current) {
                path.unshift({ x: current.x, y: current.y });
                current = current.parent;
            }
            
            return path;
        }

        // Enhanced unit movement with A* pathfinding
        function setUnitPath(unit, targetX, targetY) {
            // Convert screen coordinates to hex coordinates using helper functions
            const startHex = screenToHex(unit.x, unit.y);
            const goalHex = screenToHex(targetX, targetY);
            
            // Find path using A*
            const path = findPathAStar(startHex.x, startHex.y, goalHex.x, goalHex.y, unit.animal);
            
            if (path && path.length > 1) {
                unit.path = path.slice(1); // Remove starting position
                unit.pathIndex = 0;
                unit.isMoving = true;
                unit.targetX = null;
                unit.targetY = null;
                console.log(`üó∫Ô∏è ${unit.animal} found path with ${path.length} steps`);
            } else {
                // Fallback to direct movement
                unit.targetX = targetX;
                unit.targetY = targetY;
                unit.isMoving = true;
                unit.path = null;
                console.log(`‚ö†Ô∏è ${unit.animal} using direct movement (no A* path found)`);
            }
        }

        // Try to find an alternative movement direction when blocked (legacy fallback)
        function findAlternativeMove(unit, originalMoveX, originalMoveY) {
            // Try several alternative directions around the obstacle
            const alternatives = [
                { x: originalMoveX * 0.7, y: originalMoveY * 0.7 + unit.speed * 0.5 }, // Slight right
                { x: originalMoveX * 0.7, y: originalMoveY * 0.7 - unit.speed * 0.5 }, // Slight left
                { x: originalMoveX * 0.5, y: originalMoveY * 0.9 }, // More vertical
                { x: originalMoveX * 0.9, y: originalMoveY * 0.5 }, // More horizontal
                { x: -originalMoveY * 0.3, y: originalMoveX * 0.3 }, // Perpendicular right
                { x: originalMoveY * 0.3, y: -originalMoveX * 0.3 }  // Perpendicular left
            ];
            
            for (const alt of alternatives) {
                const testX = unit.x + alt.x;
                const testY = unit.y + alt.y;
                
                // Use new hex boundary collision detection
                if (!checkHexCollision(testX, testY, unit.animal)) {
                    return alt;
                }
            }
            
            return null; // No alternative movement found
        }

        function selectAllUnitsOfType(animalType) {
            gameState.selectedUnits = gameState.units.filter(unit => unit.animal === animalType && unit.team === 'player');
            updateSelectedCount();
            updateUnitSelectionVisuals();

            // Visual feedback
            const buttons = document.querySelectorAll('.animal-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-animal="${animalType}"]`).classList.add('active');
        }

        function createUnitModel(unit) {
            const modelContainer = document.createElement('div');
            modelContainer.className = 'unit-model';
            modelContainer.id = `unit-${unit.id}`;
            
            const modelViewer = document.createElement('model-viewer');
            modelViewer.src = animalConfigs[unit.animal].model;
            modelViewer.alt = `${unit.animal} unit`;
            modelViewer.autoRotate = false;
            modelViewer.cameraControls = false;
            modelViewer.disableZoom = true;
            modelViewer.rotationPerSecond = '0deg';
            modelViewer.style.width = (unit.size * 3) + 'px';
            modelViewer.style.height = (unit.size * 3) + 'px';
            
            // Fix camera and framing to prevent clipping
            modelViewer.cameraOrbit = '0deg 90deg 50m';
            modelViewer.fieldOfView = '10deg';
            modelViewer.minCameraOrbit = 'auto auto auto';
            modelViewer.maxCameraOrbit = 'auto auto auto';
            modelViewer.setAttribute('camera-target', 'auto auto auto');
            modelViewer.setAttribute('max-field-of-view', '45deg');
            modelViewer.setAttribute('min-field-of-view', '5deg');
            
            // Core model-viewer settings to prevent internal clipping
            modelViewer.setAttribute('auto-rotate-delay', '0');
            modelViewer.setAttribute('interaction-prompt', 'none');
            modelViewer.setAttribute('loading', 'eager');
            modelViewer.setAttribute('reveal', 'auto');
            
            // Wait for model to load then adjust framing
            modelViewer.addEventListener('load', () => {
                // Get the model's actual bounds and adjust camera accordingly
                setTimeout(() => {
                    try {
                        const center = modelViewer.getCameraTarget();
                        const bounds = modelViewer.getBoundingBoxCenter();
                        // Set camera far enough to see entire model
                        modelViewer.cameraOrbit = '0deg 75deg 100m';
                        modelViewer.fieldOfView = '15deg';
                    } catch (e) {
                        // Fallback if bounds calculation fails
                        modelViewer.cameraOrbit = '0deg 75deg 80m';
                        modelViewer.fieldOfView = '20deg';
                    }
                }, 100);
            });
            
            modelContainer.appendChild(modelViewer);
            document.getElementById('modelsContainer').appendChild(modelContainer);
            
            return modelContainer;
        }

        function spawnUnit(base) {
            const angle = Math.random() * Math.PI * 2;
            const distance = base.size + 30;
            
            const unit = {
                animal: base.animal,
                team: base.team,
                x: base.x + Math.cos(angle) * distance,
                y: base.y + Math.sin(angle) * distance,
                targetX: null,
                targetY: null,
                isMoving: false,
                size: animalConfigs[base.animal].size,
                speed: animalConfigs[base.animal].speed,
                id: Date.now() + Math.random(),
                modelElement: null,
                // A* pathfinding properties
                path: null,
                pathIndex: 0
            };

            // Create 3D model for the unit
            unit.modelElement = createUnitModel(unit);
            
            gameState.units.push(unit);
            gameState.population++;
        }

        function updateUnits(deltaTime) {
            gameState.units.forEach(unit => {
                                if (unit.isMoving) {
                    // A* path-based movement
                    if (unit.path && unit.pathIndex < unit.path.length) {
                        const currentTarget = unit.path[unit.pathIndex];
                        const targetPos = hexToScreen(currentTarget.x, currentTarget.y);
                        
                        const dx = targetPos.x - unit.x;
                        const dy = targetPos.y - unit.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 10) { // Increased threshold for more precise movement
                            const moveX = (dx / distance) * unit.speed;
                            const moveY = (dy / distance) * unit.speed;
                            
                            // Calculate next position
                            const nextX = unit.x + moveX;
                            const nextY = unit.y + moveY;
                            
                            // Check for hex boundary collision at the new position
                            if (!checkHexCollision(nextX, nextY, unit.animal)) {
                                // Apply position constraints to keep unit centered
                                const constrainedPos = constrainUnitToHex(nextX, nextY, unit.animal);
                                unit.x = constrainedPos.x;
                                unit.y = constrainedPos.y;
                                
                                // Rotate model to face movement direction
                                if (unit.modelElement) {
                                    const angleRad = Math.atan2(dy, dx);
                                    const angleDeg = (angleRad * 180 / Math.PI);
                                    const modelViewer = unit.modelElement.querySelector('model-viewer');
                                    if (modelViewer) {
                                        const yaw = -(angleDeg - 90);
                                        modelViewer.setAttribute('rotation', `0deg ${yaw.toFixed(2)}deg 0deg`);
                                    }
                                }
                            } else {
                                // Collision detected - try to find alternative path or stop
                                console.log(`üö´ ${unit.animal} collision detected at (${Math.round(nextX)}, ${Math.round(nextY)}) - recalculating path`);
                                
                                // Recalculate path from current position
                                const currentHex = screenToHex(unit.x, unit.y);
                                const finalTarget = unit.path[unit.path.length - 1];
                                const newPath = findPathAStar(currentHex.x, currentHex.y, finalTarget.x, finalTarget.y, unit.animal);
                                
                                if (newPath && newPath.length > 1) {
                                    unit.path = newPath.slice(1);
                                    unit.pathIndex = 0;
                                } else {
                                    // No path available - stop movement
                                    unit.isMoving = false;
                                    unit.path = null;
                                    unit.pathIndex = 0;
                                }
                            }
                        } else {
                            // Reached current waypoint, move to next
                            unit.pathIndex++;
                            if (unit.pathIndex >= unit.path.length) {
                                // Reached final destination
                                unit.isMoving = false;
                                unit.path = null;
                                unit.pathIndex = 0;
                            }
                        }
                    }
                                        // Legacy direct movement (fallback)
                    else if (unit.targetX !== null && unit.targetY !== null) {
                        const dx = unit.targetX - unit.x;
                        const dy = unit.targetY - unit.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 10) { // Increased threshold for consistency
                            const moveX = (dx / distance) * unit.speed;
                            const moveY = (dy / distance) * unit.speed;
                            
                            // Calculate next position
                            const nextX = unit.x + moveX;
                            const nextY = unit.y + moveY;
                            
                            // Check for hex boundary collision at the new position
                            if (!checkHexCollision(nextX, nextY, unit.animal)) {
                                // Apply position constraints to keep unit centered
                                const constrainedPos = constrainUnitToHex(nextX, nextY, unit.animal);
                                unit.x = constrainedPos.x;
                                unit.y = constrainedPos.y;
                                
                                // Rotate model to face movement direction
                                if (unit.modelElement) {
                                    const angleRad = Math.atan2(dy, dx);
                                    const angleDeg = (angleRad * 180 / Math.PI);
                                    const modelViewer = unit.modelElement.querySelector('model-viewer');
                                    if (modelViewer) {
                                        const yaw = -(angleDeg - 90);
                                        modelViewer.setAttribute('rotation', `0deg ${yaw.toFixed(2)}deg 0deg`);
                                    }
                                }
                            } else {
                                // Collision detected - stop movement and try to find A* path
                                console.log(`üö´ ${unit.animal} collision in legacy movement - switching to A* pathfinding`);
                                setUnitPath(unit, unit.targetX, unit.targetY);
                            }
                        } else {
                            unit.isMoving = false;
                            unit.targetX = null;
                            unit.targetY = null;
                        }
                    }
                }

                if (unit.team === 'enemy' && !unit.isMoving) {
                    // Simple AI: move toward nearest player base
                    const playerBases = gameState.bases.filter(b => b.team === 'player');
                    if (playerBases.length > 0) {
                        let nearest = playerBases[0];
                        let nearestDist = Math.hypot(nearest.x - unit.x, nearest.y - unit.y);
                        playerBases.forEach(b => {
                            const d = Math.hypot(b.x - unit.x, b.y - unit.y);
                            if (d < nearestDist) {
                                nearest = b;
                                nearestDist = d;
                            }
                        });
                        unit.targetX = nearest.x;
                        unit.targetY = nearest.y;
                        unit.isMoving = true;
                    }
                }
            });
            
            updateUnitModelPositions();
        }

        function updateUnitModelPositions() {
            gameState.units.forEach(unit => {
                if (unit.modelElement) {
                    const modelSize = unit.size * 3; // Keep consistent with creation size
                    const screenX = unit.x - gameState.camera.x - modelSize/2;
                    const screenY = unit.y - gameState.camera.y - modelSize/2;
                    
                    unit.modelElement.style.left = screenX + 'px';
                    unit.modelElement.style.top = screenY + 'px';
                    // Don't resize - maintain original size to prevent clipping
                    // unit.modelElement.style.width = modelSize + 'px';
                    // unit.modelElement.style.height = modelSize + 'px';
                }
            });
            
            // No tree position updates needed
        }

        function updateUnitSelectionVisuals() {
            gameState.units.forEach(unit => {
                if (unit.modelElement) {
                    if (gameState.selectedUnits.includes(unit)) {
                        unit.modelElement.classList.add('selected');
                    } else {
                        unit.modelElement.classList.remove('selected');
                    }
                }
            });
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = gameState.selectedUnits.length;
            document.getElementById('population').textContent = gameState.population;
        }

        function render() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Save context for camera transform
            ctx.save();
            ctx.translate(-gameState.camera.x, -gameState.camera.y);

            // Draw bases
            gameState.bases.forEach(base => {
                const config = animalConfigs[base.animal];
                
                // Base structure
                ctx.fillStyle = '#4a4a4a';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                
                // Different base shapes based on animal
                if (config.baseStyle === 'hive') {
                    drawHexagon(ctx, base.x, base.y, base.size);
                } else if (config.baseStyle === 'pond') {
                    ctx.beginPath();
                    ctx.arc(base.x, base.y, base.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.fillRect(base.x - base.size/2, base.y - base.size/2, base.size, base.size);
                    ctx.strokeRect(base.x - base.size/2, base.y - base.size/2, base.size, base.size);
                }

                // Base emoji
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#fff';
                ctx.fillText(config.emoji, base.x, base.y + 8);
            });

            // Draw movement target indicators for selected units
            gameState.selectedUnits.forEach(unit => {
                if (unit.isMoving && unit.targetX && unit.targetY) {
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(unit.x, unit.y);
                    ctx.lineTo(unit.targetX, unit.targetY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Target marker
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.arc(unit.targetX, unit.targetY, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.restore();

            // Draw mini-map
            renderMiniMap();
        }

        function drawHexagon(ctx, x, y, size) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                const px = x + Math.cos(angle) * size;
                const py = y + Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function renderMiniMap() {
            const miniCanvas = document.getElementById('miniMapCanvas');
            const miniCtx = miniCanvas.getContext('2d');
            
            // Clear mini-map
            miniCtx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);
            
            const scaleX = miniCanvas.width / gameState.mapSize.width;
            const scaleY = miniCanvas.height / gameState.mapSize.height;

            // Draw bases on mini-map
            gameState.bases.forEach(base => {
                miniCtx.fillStyle = '#4a4a4a';
                miniCtx.fillRect(
                    base.x * scaleX - 2, 
                    base.y * scaleY - 2, 
                    4, 4
                );
            });

            // Draw units on mini-map
            gameState.units.forEach(unit => {
                miniCtx.fillStyle = gameState.selectedUnits.includes(unit) ? '#00ff88' : '#ffffff';
                miniCtx.fillRect(
                    unit.x * scaleX - 1, 
                    unit.y * scaleY - 1, 
                    2, 2
                );
            });

            // Draw camera view
            const cameraX = gameState.camera.x * scaleX;
            const cameraY = gameState.camera.y * scaleY;
            const cameraW = window.innerWidth * scaleX;
            const cameraH = window.innerHeight * scaleY;
            
            miniCtx.strokeStyle = '#fff';
            miniCtx.lineWidth = 1;
            miniCtx.strokeRect(cameraX, cameraY, cameraW, cameraH);
        }

        function gameLoop() {
            if (!gameState.gameStarted) return;

            const currentTime = Date.now();
            const deltaTime = currentTime - (gameState.lastTime || currentTime);
            gameState.lastTime = currentTime;

            // Spawn units from bases
            gameState.bases.forEach(base => {
                if (currentTime - base.lastSpawn > base.spawnInterval) {
                    spawnUnit(base);
                    base.lastSpawn = currentTime;
                }
            });

            // Update units
            updateUnits(deltaTime);

            // Render
            render();

            // Continue game loop
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html> 