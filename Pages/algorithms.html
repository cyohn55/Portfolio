<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Algorithms</title>
    <meta name="description" content="Recursion at all levels.">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../images/algorithms.webp">
    <link rel="icon" type="image/png" sizes="32x32" href="../images/algorithms.webp">
    <link rel="icon" type="image/png" sizes="16x16" href="../images/algorithms.webp">
    <link rel="apple-touch-icon" href="../images/algorithms.webp">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://cyohn55.github.io/Portfolio/Pages/algorithms.html">
    <meta property="og:title" content="Algorithm Analysis & Recursion">
    <meta property="og:description" content="Recursion at all levels.">
    <meta property="og:image" content="https://cyohn55.github.io/Portfolio/images/algorithms.webp">
    <meta property="og:site_name" content="Cody's Portfolio">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://cyohn55.github.io/Portfolio/Pages/algorithms.html">
    <meta property="twitter:title" content="Algorithm Analysis & Recursion">
    <meta property="twitter:description" content="Recursion at all levels.">
    <meta property="twitter:image" content="https://cyohn55.github.io/Portfolio/images/algorithms.webp">
    
    <!-- Link to CSS -->
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h2>Code(Yohn's) Portfolio</h2>
        <nav>
            <ul>
                <li><a href="../index.html" class="home-icon"><span class="house-silhouette"></span></a></li>
                <li><div class="theme-toggle-wrapper">
                    <div class="theme-toggle" id="darkModeToggle" aria-label="Toggle dark mode">
                        <div class="toggle-track">
                            <div class="toggle-icons">
                                <span class="sun-icon">‚òÄÔ∏è</span>
                                <span class="moon-icon">üåô</span>
                            </div>
                            <div class="toggle-slider"></div>
                        </div>
                    </div>
                </div></li>
            </ul>
        </nav>
    </header>

    <div class="content">
        <!-- Responsive Video Container -->
        <div class="video-container">
            <iframe src="https://www.youtube.com/embed/YzT8zDPihmc?autoplay=1&loop=1&playlist=YzT8zDPihmc&mute=1" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>         
        </div>

    <!-- Written Section -->
    <div class="wrap-text-container">
<p><strong>When should you consider using recursive algorithms when writing a program?</strong></p>
    <p>To understand when we should use recursive algorithms, we must first understand how recursion works. A recursive algorithm is a program that repeatedly calls itself until reaching one or more base cases. (Eck, 2019). Recursion allows us to solve complex problems by breaking the problem down into smaller repeatable subroutines. For example, a Rubik's cube is difficult to solve by brute-forcing a solution. However, if we break down the problem into repeatable steps, we can solve the problem quickly.</p>
    <p>When writing our programs, we must identify if recursion can be applied to the problem and weigh the pros and cons of using recursion versus non-recursive techniques. Two basic requirements for a recursive algorithm are: the problem can be solved by reaching one or more base cases (i.e., searching an empty list) and that we can reduce the larger problem to smaller steps. (Eck, 2019). We can achieve this, in part, by passing in different parameters to our subroutines that specify where exactly to search in a data set. This reduces the amount of memory that needs to be allocated at one time because we don't need to look at the whole data set. Instead, we can process parts of the dataset by defining parameters to our subroutines that point to what data we want to process, running the steps involved in solving the problem, and then moving on to another part of the dataset. This recursive process repeatedly runs until reaching one of the base cases.</p>
    <p>However, recursion isn't always the best option for every problem. For one, recursion is difficult to understand and implement programmatically. It may become a question of: "will it take longer to write the recursive program, or would a non-recursive approach be faster to implement?" Another thing to consider is, improper implementations of recursion can lead to infinite recursion, causing StackOverflowErrors in Java and computer crashes when a computer's memory limit is exceeded. (Eck, 2019). Other things to consider are "how large is the problem?" and "can a non-recursive algorithm work just as well or better than a recursive algorithm?" In many instances, iterative approaches are the better option, since they use less memory.</p>
    <p>In conclusion, recursive algorithms can be powerful tools in a programmer's arsenal when tackling complex problems. However, recursion can often be difficult to understand and implement, therefore, iteration is often the best approach.</p>
    </div>

    <!-- Code Section -->
    <div class="code-container">
        <pre>
<h3><strong>Recursive Binary Search algorithm (Eck, 2019, 9.1.1 Recursive Binary Search).</strong></h3>
static int binarySearch(int[] A, int loIndex, int hiIndex, int value) {
                      
    if (loIndex > hiIndex) {  // The 'if' conditional is considered a base case.
        return -1;            // The base case in this instance returns -1 if the list is empty.
    }
    else {
        int middle = (loIndex + hiIndex) / 2;
        if (value == A[middle]) // This is another base case if the value is found in the middle of the dataset.
            return middle;
        else if (value < A[middle])
            return binarySearch(A, loIndex, middle - 1, value); // Both else conditionals call the 'binarySearch' function recursively.
        else                                                    // paramaters that specify where to search the data are updated with
            return binarySearch(A, middle + 1, hiIndex, value); // each recursive call to the 'binarySearch' function.
    }              
}

<h3><strong>References</strong></h3>            
Eck, D. J. (2019). <a href="http://math.hws.edu/javanotes">Introduction to programming using Java, version 8.1.</a> Hobart and William Smith Colleges.               
            </pre>
        </div>
    </div>

    <footer>
        <p>&copy; 2025 Cody Yohn. All rights reserved.</p>
    </footer>
    <script src="../script.js"></script>
</body>
</html>
